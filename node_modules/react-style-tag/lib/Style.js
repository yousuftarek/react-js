'use strict';

exports.__esModule = true;
exports.returnNode = exports.relocateNode = exports.getStyleForState = exports.componentWillUnmount = exports.componentDidUpdate = exports.getSnapshotBeforeUpdate = exports.componentDidMount = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactParm = require('react-parm');

var _blob = require('./blob');

var _constants = require('./constants');

var _options = require('./options');

var _styles = require('./styles');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // external dependencies


// blob


// constants


// options


// styles


/**
 * @function componentDidMount
 *
 * @description
 * on mount, relocate the node
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.relocateNote the method to relocate the node to the head
 * @returns {void}
 */
var componentDidMount = exports.componentDidMount = function componentDidMount(_ref) {
  var node = _ref.node,
      relocateNode = _ref.relocateNode;
  return relocateNode(node);
};

/**
 * @function getSnapshotBeforeUpdate
 *
 * @description
 * before the update occurs, if the sourceMap requirements have changed, return the node to its original position
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.returnNode the method to return the node to its original parent
 * @returns {null}
 */
var getSnapshotBeforeUpdate = exports.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(_ref2) {
  var node = _ref2.node,
      returnNode = _ref2.returnNode;

  returnNode(node);

  return null;
};

/**
 * @function componentDidUpdate
 *
 * @description
 * on update, if the sourceMap requirements have changed then relocate the new node to the head,
 * and if the styles have changed then set them in staet
 *
 * @param {ReactComponent} instance the component instance
 * @param {function} instance.getStyleForState the method to get the new rendered style
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.relocateNote the method to relocate the node to the head
 * @param {Object} instance.props the new props of the component
 * @param {function} instance.setState the method to set the state of the component
 * @param {Array<any>} args the arguments passed to the function
 * @param {Object} previousProps the previous props of the component
 */
var componentDidUpdate = exports.componentDidUpdate = function componentDidUpdate(_ref3, _ref4) {
  var getStyleForState = _ref3.getStyleForState,
      node = _ref3.node,
      relocateNode = _ref3.relocateNode,
      props = _ref3.props,
      setState = _ref3.setState;
  var previousProps = _ref4[0];

  relocateNode(node);

  if (props.children !== previousProps.children) {
    setState(getStyleForState);
  }
};

/**
 * @function componentWillUnmount
 *
 * @description
 * prior to unmount, return the node to its original parent
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.returnNode the method to return the node to its original parent
 * @returns {void}
 */
var componentWillUnmount = exports.componentWillUnmount = function componentWillUnmount(_ref5) {
  var node = _ref5.node,
      returnNode = _ref5.returnNode;
  return returnNode(node);
};

/**
 * @function getStyleForState
 *
 * @description
 * get the styles to be used for the rendered tag
 *
 * @param {ReactComponent} instance the component instance
 * @param {Object} instance.props the new props of the component
 * @returns {{style: string}} the style strng to use in the rendered tag
 */
var getStyleForState = exports.getStyleForState = function getStyleForState(_ref6) {
  var props = _ref6.props;
  return {
    style: (0, _styles.getRenderedStyles)(props.children, {
      isCompressed: (0, _options.getCoalescedOption)(props, 'isCompressed'),
      isMinified: (0, _options.getCoalescedOption)(props, 'isMinified'),
      isPrefixed: (0, _options.getCoalescedOption)(props, 'isPrefixed')
    })
  };
};

/**
 * @function relocateNode
 *
 * @description
 * relocate the node to the bottom of the head
 *
 * @param {ReactComponent} instance the component instance
 * @param {Array<any>} args the arguments passed to the function
 * @param {HTMLElement} node the node to render the styles into
 */
var relocateNode = exports.relocateNode = function relocateNode(instance, _ref7) {
  var node = _ref7[0];

  if (typeof document !== 'undefined' && node) {
    instance.originalParent = node.parentNode;

    instance.originalParent.removeChild(node);
    document.head.appendChild(node);
  }
};

/**
 * @function returnNode
 *
 * @description
 * return the node to the original parent
 *
 * @param {ReactComponent} instance the component instance
 * @param {Array<any>} args the arguments passed to the function
 * @param {HTMLElement} node the node to render the styles into
 */
var returnNode = exports.returnNode = function returnNode(instance, _ref8) {
  var node = _ref8[0];

  if (typeof document !== 'undefined' && node) {
    try {
      document.head.removeChild(node);
      instance.originalParent.appendChild(node);
    } catch (error) {
      // ignore the error
    } finally {
      instance.node = null;
      instance.originalParent = null;
    }
  }
};

var Style = function (_PureComponent) {
  _inherits(Style, _PureComponent);

  function Style(props) {
    _classCallCheck(this, Style);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.componentDidMount = (0, _reactParm.createMethod)(_this, componentDidMount);
    _this.componentDidUpdate = (0, _reactParm.createMethod)(_this, componentDidUpdate);
    _this[_constants.SUPPORTS_BEFORE_UPDATE_SNAPSHOT ? 'getSnapshotBeforeUpdate' : 'componentWillUpdate'] = (0, _reactParm.createMethod)(_this, getSnapshotBeforeUpdate);
    _this.componentWillUnmount = (0, _reactParm.createMethod)(_this, componentWillUnmount);
    _this.linkHref = null;
    _this.node = null;
    _this.originalParent = null;
    _this.getCachedLinkHref = (0, _blob.createGetCachedLinkHref)();
    _this.getStyleForState = (0, _reactParm.createMethod)(_this, getStyleForState);
    _this.relocateNode = (0, _reactParm.createMethod)(_this, relocateNode);
    _this.returnNode = (0, _reactParm.createMethod)(_this, returnNode);


    _this.state = getStyleForState({ props: props });
    return _this;
  }

  // lifecycle methods

  /* eslint-disable react/sort-comp */

  /* eslint-enable */


  // instance values


  // static methods


  // instance methods


  Style.prototype.render = function render() {
    var _props = this.props,
        childrenIgnored = _props.children,
        hasSourceMapIgnored = _props.hasSourceMap,
        isMinifiedIgnored = _props.isCompressed,
        isPrefixedIgnored = _props.isPrefixed,
        props = _objectWithoutProperties(_props, ['children', 'hasSourceMap', 'isCompressed', 'isPrefixed']);

    var style = this.state.style;


    if ((0, _options.getCoalescedOption)(this.props, 'hasSourceMap')) {
      if ((0, _blob.hasBlobSupport)()) {
        return (
          /* eslint-disable prettier */
          _react2.default.createElement('link', _extends({}, props, {
            href: this.getCachedLinkHref(style),
            ref: (0, _reactParm.createElementRef)(this, 'node'),
            rel: 'stylesheet'
          }))
          /* eslint-enable */

        );
      }

      /* eslint-disable no-console */
      console.error('To support sourcemaps for react-style-tag you need Blob support, and the browser you are using does not currently support it. You should include a polyfill prior to the rendering of this component.');
      /* eslint-enable */
    }

    return _react2.default.createElement(
      'style',
      _extends({
        ref: (0, _reactParm.createElementRef)(this, 'node')
      }, props),
      style
    );
  };

  return Style;
}(_react.PureComponent);

Style.propTypes = {
  children: _propTypes2.default.string.isRequired,
  hasSourceMap: _propTypes2.default.bool,
  id: _propTypes2.default.string,
  isCompressed: _propTypes2.default.bool,
  isMinified: _propTypes2.default.bool,
  isPrefixed: _propTypes2.default.bool
};
Style.setGlobalOptions = _options.setGlobalOptions;
exports.default = Style;