var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// external dependencies
import PropTypes from 'prop-types';
import React, { PureComponent } from 'react';
import { createElementRef, createMethod } from 'react-parm';

// blob
import { createGetCachedLinkHref, hasBlobSupport } from './blob';

// constants
import { SUPPORTS_BEFORE_UPDATE_SNAPSHOT } from './constants';

// options
import { getCoalescedOption, setGlobalOptions } from './options';

// styles
import { getRenderedStyles } from './styles';

/**
 * @function componentDidMount
 *
 * @description
 * on mount, relocate the node
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.relocateNote the method to relocate the node to the head
 * @returns {void}
 */
export var componentDidMount = function componentDidMount(_ref) {
  var node = _ref.node,
      relocateNode = _ref.relocateNode;
  return relocateNode(node);
};

/**
 * @function getSnapshotBeforeUpdate
 *
 * @description
 * before the update occurs, if the sourceMap requirements have changed, return the node to its original position
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.returnNode the method to return the node to its original parent
 * @returns {null}
 */
export var getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(_ref2) {
  var node = _ref2.node,
      returnNode = _ref2.returnNode;

  returnNode(node);

  return null;
};

/**
 * @function componentDidUpdate
 *
 * @description
 * on update, if the sourceMap requirements have changed then relocate the new node to the head,
 * and if the styles have changed then set them in staet
 *
 * @param {ReactComponent} instance the component instance
 * @param {function} instance.getStyleForState the method to get the new rendered style
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.relocateNote the method to relocate the node to the head
 * @param {Object} instance.props the new props of the component
 * @param {function} instance.setState the method to set the state of the component
 * @param {Array<any>} args the arguments passed to the function
 * @param {Object} previousProps the previous props of the component
 */
export var componentDidUpdate = function componentDidUpdate(_ref3, _ref4) {
  var getStyleForState = _ref3.getStyleForState,
      node = _ref3.node,
      relocateNode = _ref3.relocateNode,
      props = _ref3.props,
      setState = _ref3.setState;
  var previousProps = _ref4[0];

  relocateNode(node);

  if (props.children !== previousProps.children) {
    setState(getStyleForState);
  }
};

/**
 * @function componentWillUnmount
 *
 * @description
 * prior to unmount, return the node to its original parent
 *
 * @param {ReactComponent} instance the component instance
 * @param {HTMLElement} instance.node the node to render the styles into
 * @param {function} instance.returnNode the method to return the node to its original parent
 * @returns {void}
 */
export var componentWillUnmount = function componentWillUnmount(_ref5) {
  var node = _ref5.node,
      returnNode = _ref5.returnNode;
  return returnNode(node);
};

/**
 * @function getStyleForState
 *
 * @description
 * get the styles to be used for the rendered tag
 *
 * @param {ReactComponent} instance the component instance
 * @param {Object} instance.props the new props of the component
 * @returns {{style: string}} the style strng to use in the rendered tag
 */
export var getStyleForState = function getStyleForState(_ref6) {
  var props = _ref6.props;
  return {
    style: getRenderedStyles(props.children, {
      isCompressed: getCoalescedOption(props, 'isCompressed'),
      isMinified: getCoalescedOption(props, 'isMinified'),
      isPrefixed: getCoalescedOption(props, 'isPrefixed')
    })
  };
};

/**
 * @function relocateNode
 *
 * @description
 * relocate the node to the bottom of the head
 *
 * @param {ReactComponent} instance the component instance
 * @param {Array<any>} args the arguments passed to the function
 * @param {HTMLElement} node the node to render the styles into
 */
export var relocateNode = function relocateNode(instance, _ref7) {
  var node = _ref7[0];

  if (typeof document !== 'undefined' && node) {
    instance.originalParent = node.parentNode;

    instance.originalParent.removeChild(node);
    document.head.appendChild(node);
  }
};

/**
 * @function returnNode
 *
 * @description
 * return the node to the original parent
 *
 * @param {ReactComponent} instance the component instance
 * @param {Array<any>} args the arguments passed to the function
 * @param {HTMLElement} node the node to render the styles into
 */
export var returnNode = function returnNode(instance, _ref8) {
  var node = _ref8[0];

  if (typeof document !== 'undefined' && node) {
    try {
      document.head.removeChild(node);
      instance.originalParent.appendChild(node);
    } catch (error) {
      // ignore the error
    } finally {
      instance.node = null;
      instance.originalParent = null;
    }
  }
};

var Style = function (_PureComponent) {
  _inherits(Style, _PureComponent);

  function Style(props) {
    _classCallCheck(this, Style);

    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));

    _this.componentDidMount = createMethod(_this, componentDidMount);
    _this.componentDidUpdate = createMethod(_this, componentDidUpdate);
    _this[SUPPORTS_BEFORE_UPDATE_SNAPSHOT ? 'getSnapshotBeforeUpdate' : 'componentWillUpdate'] = createMethod(_this, getSnapshotBeforeUpdate);
    _this.componentWillUnmount = createMethod(_this, componentWillUnmount);
    _this.linkHref = null;
    _this.node = null;
    _this.originalParent = null;
    _this.getCachedLinkHref = createGetCachedLinkHref();
    _this.getStyleForState = createMethod(_this, getStyleForState);
    _this.relocateNode = createMethod(_this, relocateNode);
    _this.returnNode = createMethod(_this, returnNode);


    _this.state = getStyleForState({ props: props });
    return _this;
  }

  // lifecycle methods

  /* eslint-disable react/sort-comp */

  /* eslint-enable */


  // instance values


  // static methods


  // instance methods


  Style.prototype.render = function render() {
    var _props = this.props,
        childrenIgnored = _props.children,
        hasSourceMapIgnored = _props.hasSourceMap,
        isMinifiedIgnored = _props.isCompressed,
        isPrefixedIgnored = _props.isPrefixed,
        props = _objectWithoutProperties(_props, ['children', 'hasSourceMap', 'isCompressed', 'isPrefixed']);

    var style = this.state.style;


    if (getCoalescedOption(this.props, 'hasSourceMap')) {
      if (hasBlobSupport()) {
        return (
          /* eslint-disable prettier */
          React.createElement('link', _extends({}, props, {
            href: this.getCachedLinkHref(style),
            ref: createElementRef(this, 'node'),
            rel: 'stylesheet'
          }))
          /* eslint-enable */

        );
      }

      /* eslint-disable no-console */
      console.error('To support sourcemaps for react-style-tag you need Blob support, and the browser you are using does not currently support it. You should include a polyfill prior to the rendering of this component.');
      /* eslint-enable */
    }

    return React.createElement(
      'style',
      _extends({
        ref: createElementRef(this, 'node')
      }, props),
      style
    );
  };

  return Style;
}(PureComponent);

Style.propTypes = {
  children: PropTypes.string.isRequired,
  hasSourceMap: PropTypes.bool,
  id: PropTypes.string,
  isCompressed: PropTypes.bool,
  isMinified: PropTypes.bool,
  isPrefixed: PropTypes.bool
};
Style.setGlobalOptions = setGlobalOptions;


export default Style;