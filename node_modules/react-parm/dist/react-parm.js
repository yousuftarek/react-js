(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (factory((global.ReactParm = {}),global.React,global.ReactDOM));
}(this, (function (exports,React,reactDom) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  // external dependencies

  /**
   * @function bindSetState
   *
   * @description
   * bind the setState method to the component instance to ensure it can be used in a functional way
   *
   * @param {ReactComponent} instance the instance to bind setState to
   * @returns {void}
   */
  var bindSetState = function bindSetState(instance) {
    return instance.setState = instance.setState.bind(instance);
  };

  /**
   * @function isClassComponent
   *
   * @description
   * is the value passed a valid react component class instance
   *
   * @param {any} value the value to test
   * @returns {boolean} is the value a react component instance
   */
  var isClassComponent = function isClassComponent(value) {
    return !!value && value instanceof React.Component;
  };

  /**
   * @function logInvalidInstanceError
   *
   * @description
   * notify the user that the instance passed is invalid
   *
   * @param {string} type the type of creator being called
   * @returns {void}
   */
  var logInvalidInstanceError = function logInvalidInstanceError(type) {
    return console.error('The instance provided for use with the ' + type + ' is not a valid React component instance.');
  }; // eslint-disable-line no-console

  /**
   * @function createRefCreator
   *
   * @description
   * create a method that will assign a ref value to the instance passed
   *
   * @param {function} getter the function that gets the component value for the ref
   * @returns {function(ReactComponent, string): function((HTMLElement|Component)): void} the ref create
   */
  var createRefCreator = function createRefCreator(getter) {
    return function (instance, ref) {
      return isClassComponent(instance) ? function (component) {
        return instance[ref] = getter(component);
      } : logInvalidInstanceError('ref');
    };
  };

  /**
   * @function getNamespacedRef
   *
   * @description
   * get the ref that is a combination of the raw component and the component's underlying HTML element
   *
   * @param {ReactComponent} component the component to assin
   * @returns {{component: ReactComponent, element: HTMLElement}} the namespaced ref
   */
  var getNamespacedRef = function getNamespacedRef(component) {
    return { component: component, element: reactDom.findDOMNode(component) };
  };

  /**
   * @function identity
   *
   * @description
   * return the first parameter passed
   *
   * @param {any} value the value to pass through
   * @returns {any} the first parameter passed
   */
  var identity = function identity(value) {
    return value;
  };

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  /**
   * @function createCombinedRef
   *
   * @description
   * create a ref that assigns both the raw component and the underlying HTML element to the instance on a namespace
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {{component: ReactComponent, element: HTMLElement}} the combined ref
   */
  var createCombinedRef = createRefCreator(getNamespacedRef);

  /**
   * @function createComponentRef
   *
   * @description
   * create a ref that assigns the component itself to the instance
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {ReactComponent} the component ref
   */
  var createComponentRef = createRefCreator(identity);

  /**
   * @function createElementRef
   *
   * @description
   * create a ref that assigns the component's underlying HTML element to the instance
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {HTMLElement} the element ref
   */
  var createElementRef = createRefCreator(reactDom.findDOMNode);

  /**
   * @function createMethod
   *
   * @description
   * create a method that is a pure version of the lifecycle / instance method passed to it
   *
   * the conditional function return is to ensure the method is called with as performant a way as possible
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} method the instance method
   * @param {Array<any>} extraArgs additional args to pass to the method
   * @returns {function(...Array<any>): any} the method with the instance passed as value
   */
  var createMethod = function createMethod(instance, method) {
    for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      extraArgs[_key - 2] = arguments[_key];
    }

    return isClassComponent(instance) ? bindSetState(instance) && function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return method.call(instance, instance, args, extraArgs);
    } : logInvalidInstanceError('method');
  }; // eslint-disable-line no-console

  /**
   * @function createComponent
   *
   * @description
   * create a component from the render method and any options passed
   *
   * @param {function} render the function to render the component
   * @param {Object} [options={}] the options to render the component with
   * @param {function} [getInitialState] the method to get the initial state with
   * @param {boolean} [isPure] is PureComponent used
   * @param {Object} [state] the initial state
   * @returns {ReactComponent} the component class
   */
  var createComponent = function createComponent(render) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var getInitialState = _ref.getInitialState,
        isPure = _ref.isPure,
        state = _ref.state,
        options = _objectWithoutProperties(_ref, ['getInitialState', 'isPure', 'state']);

    var Constructor = isPure ? React.PureComponent : React.Component;

    function ParmComponent(initialProps) {
      var _this = this;

      Constructor.call(this, initialProps);

      this.state = typeof getInitialState === 'function' ? createMethod(this, getInitialState)() : state || null;

      Object.keys(options).forEach(function (key) {
        _this[key] = typeof options[key] === 'function' ? createMethod(_this, options[key]) : options[key];
      });

      this.render = createMethod(this, render);

      return this;
    }

    ParmComponent.prototype = Object.create(Constructor.prototype);

    ParmComponent.displayName = render.displayName || render.name || 'ParmComponent';
    ParmComponent.propTypes = render.propTypes;
    ParmComponent.contextTypes = render.contextTypes;
    ParmComponent.childContextTypes = render.childContextTypes;
    ParmComponent.defaultProps = render.defaultProps;

    return ParmComponent;
  };

  exports.createCombinedRef = createCombinedRef;
  exports.createComponentRef = createComponentRef;
  exports.createElementRef = createElementRef;
  exports.createMethod = createMethod;
  exports.createComponent = createComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-parm.js.map
