'use strict';

exports.__esModule = true;
exports.createComponent = exports.createMethod = exports.createElementRef = exports.createComponentRef = exports.createCombinedRef = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } // external dependencies


// utils


/**
 * @function createCombinedRef
 *
 * @description
 * create a ref that assigns both the raw component and the underlying HTML element to the instance on a namespace
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {{component: ReactComponent, element: HTMLElement}} the combined ref
 */
var createCombinedRef = exports.createCombinedRef = (0, _utils.createRefCreator)(_utils.getNamespacedRef);

/**
 * @function createComponentRef
 *
 * @description
 * create a ref that assigns the component itself to the instance
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {ReactComponent} the component ref
 */
var createComponentRef = exports.createComponentRef = (0, _utils.createRefCreator)(_utils.identity);

/**
 * @function createElementRef
 *
 * @description
 * create a ref that assigns the component's underlying HTML element to the instance
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {HTMLElement} the element ref
 */
var createElementRef = exports.createElementRef = (0, _utils.createRefCreator)(_reactDom.findDOMNode);

/**
 * @function createMethod
 *
 * @description
 * create a method that is a pure version of the lifecycle / instance method passed to it
 *
 * the conditional function return is to ensure the method is called with as performant a way as possible
 *
 * @param {ReactComponent} instance the instance the method is assigned to
 * @param {function} method the instance method
 * @param {Array<any>} extraArgs additional args to pass to the method
 * @returns {function(...Array<any>): any} the method with the instance passed as value
 */
var createMethod = exports.createMethod = function createMethod(instance, method) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  return (0, _utils.isClassComponent)(instance) ? (0, _utils.bindSetState)(instance) && function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return method.call(instance, instance, args, extraArgs);
  } : (0, _utils.logInvalidInstanceError)('method');
}; // eslint-disable-line no-console

/**
 * @function createComponent
 *
 * @description
 * create a component from the render method and any options passed
 *
 * @param {function} render the function to render the component
 * @param {Object} [options={}] the options to render the component with
 * @param {function} [getInitialState] the method to get the initial state with
 * @param {boolean} [isPure] is PureComponent used
 * @param {Object} [state] the initial state
 * @returns {ReactComponent} the component class
 */
var createComponent = function createComponent(render) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var getInitialState = _ref.getInitialState,
      isPure = _ref.isPure,
      state = _ref.state,
      options = _objectWithoutProperties(_ref, ['getInitialState', 'isPure', 'state']);

  var Constructor = isPure ? _react2.default.PureComponent : _react2.default.Component;

  function ParmComponent(initialProps) {
    var _this = this;

    Constructor.call(this, initialProps);

    this.state = typeof getInitialState === 'function' ? createMethod(this, getInitialState)() : state || null;

    Object.keys(options).forEach(function (key) {
      _this[key] = typeof options[key] === 'function' ? createMethod(_this, options[key]) : options[key];
    });

    this.render = createMethod(this, render);

    return this;
  }

  ParmComponent.prototype = Object.create(Constructor.prototype);

  ParmComponent.displayName = render.displayName || render.name || 'ParmComponent';
  ParmComponent.propTypes = render.propTypes;
  ParmComponent.contextTypes = render.contextTypes;
  ParmComponent.childContextTypes = render.childContextTypes;
  ParmComponent.defaultProps = render.defaultProps;

  return ParmComponent;
};
exports.createComponent = createComponent;