{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/hyper/Downloads/gronthik/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/hyper/Downloads/gronthik/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/hyper/Downloads/gronthik/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar referenceVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      var scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var violation = _step.value;\n\n        if (violation.scope !== binding.path.scope) {\n          state.mutableBinding = true;\n          path.stop();\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\n\nvar PathHoister =\n/*#__PURE__*/\nfunction () {\n  function PathHoister(path, scope) {\n    _classCallCheck(this, PathHoister);\n\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  _createClass(PathHoister, [{\n    key: \"isCompatibleScope\",\n    value: function isCompatibleScope(scope) {\n      for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var binding = this.bindings[key];\n\n        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getCompatibleScopes\",\n    value: function getCompatibleScopes() {\n      var scope = this.path.scope;\n\n      do {\n        if (this.isCompatibleScope(scope)) {\n          this.scopes.push(scope);\n        } else {\n          break;\n        }\n\n        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n          break;\n        }\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getAttachmentPath\",\n    value: function getAttachmentPath() {\n      var path = this._getAttachmentPath();\n\n      if (!path) return;\n      var targetScope = path.scope;\n\n      if (targetScope.path === path) {\n        targetScope = path.scope.parent;\n      }\n\n      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n        for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {\n          var name = _Object$keys2[_i2];\n          if (!targetScope.hasOwnBinding(name)) continue;\n          var binding = this.bindings[name];\n\n          if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n            continue;\n          }\n\n          var bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n          if (bindingParentPath.key >= path.key) {\n            this.attachAfter = true;\n            path = binding.path;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = binding.constantViolations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var violationPath = _step2.value;\n\n                if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n                  path = violationPath;\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return path;\n    }\n  }, {\n    key: \"_getAttachmentPath\",\n    value: function _getAttachmentPath() {\n      var scopes = this.scopes;\n      var scope = scopes.pop();\n      if (!scope) return;\n\n      if (scope.path.isFunction()) {\n        if (this.hasOwnParamBindings(scope)) {\n          if (this.scope === scope) return;\n          var bodies = scope.path.get(\"body\").get(\"body\");\n\n          for (var i = 0; i < bodies.length; i++) {\n            if (bodies[i].node._blockHoist) continue;\n            return bodies[i];\n          }\n        } else {\n          return this.getNextScopeAttachmentParent();\n        }\n      } else if (scope.path.isProgram()) {\n        return this.getNextScopeAttachmentParent();\n      }\n    }\n  }, {\n    key: \"getNextScopeAttachmentParent\",\n    value: function getNextScopeAttachmentParent() {\n      var scope = this.scopes.pop();\n      if (scope) return this.getAttachmentParentForPath(scope.path);\n    }\n  }, {\n    key: \"getAttachmentParentForPath\",\n    value: function getAttachmentParentForPath(path) {\n      do {\n        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n          return path;\n        }\n      } while (path = path.parentPath);\n    }\n  }, {\n    key: \"hasOwnParamBindings\",\n    value: function hasOwnParamBindings(scope) {\n      for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {\n        var name = _Object$keys3[_i3];\n        if (!scope.hasOwnBinding(name)) continue;\n        var binding = this.bindings[name];\n        if (binding.kind === \"param\" && binding.constant) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.path.traverse(referenceVisitor, this);\n      if (this.mutableBinding) return;\n      this.getCompatibleScopes();\n      var attachTo = this.getAttachmentPath();\n      if (!attachTo) return;\n      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n      var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n      var declarator = t.variableDeclarator(uid, this.path.node);\n      var insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n\n      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]),\n          _attachTo$insertFn2 = _slicedToArray(_attachTo$insertFn, 1),\n          attached = _attachTo$insertFn2[0];\n\n      var parent = this.path.parentPath;\n\n      if (parent.isJSXElement() && this.path.container === parent.node.children) {\n        uid = t.JSXExpressionContainer(uid);\n      }\n\n      this.path.replaceWith(t.cloneNode(uid));\n      return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n    }\n  }]);\n\n  return PathHoister;\n}();\n\nexports.default = PathHoister;","map":{"version":3,"sources":["/home/hyper/Downloads/gronthik/bookstore/node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/lib/hoister.js"],"names":["Object","defineProperty","exports","value","default","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","react","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","constantViolations","violation","mutableBinding","stop","bindings","PathHoister","scopes","attachAfter","keys","bindingIdentifierEquals","identifier","isCompatibleScope","indexOf","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","traverse","getCompatibleScopes","attachTo","getAttachmentPath","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","insertFn","isVariableDeclarator","variableDeclaration","attached","isJSXElement","children","JSXExpressionContainer","replaceWith","cloneNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;"]},"metadata":{},"sourceType":"script"}