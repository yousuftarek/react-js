{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _clone = _interopRequireDefault(require(\"lodash/clone\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {\n    var nodeType = _Object$keys[_i];\n    if (shouldIgnoreKey(nodeType)) continue;\n    var parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    var fns = visitor[nodeType];\n    delete visitor[nodeType];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        visitor[part] = fns;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {\n    var _nodeType = _Object$keys2[_i2];\n    if (shouldIgnoreKey(_nodeType)) continue;\n    var wrapper = virtualTypes[_nodeType];\n    if (!wrapper) continue;\n    var _fns = visitor[_nodeType];\n\n    for (var _i5 = 0, _Object$keys5 = Object.keys(_fns); _i5 < _Object$keys5.length; _i5++) {\n      var _type = _Object$keys5[_i5];\n      _fns[_type] = wrapCheck(wrapper, _fns[_type]);\n    }\n\n    delete visitor[_nodeType];\n\n    if (wrapper.types) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = wrapper.types[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var type = _step2.value;\n\n          if (visitor[type]) {\n            mergePair(visitor[type], _fns);\n          } else {\n            visitor[type] = _fns;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else {\n      mergePair(visitor, _fns);\n    }\n  }\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(visitor); _i3 < _Object$keys3.length; _i3++) {\n    var _nodeType2 = _Object$keys3[_i3];\n    if (shouldIgnoreKey(_nodeType2)) continue;\n    var _fns2 = visitor[_nodeType2];\n    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType2];\n    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType2];\n\n    if (deprecratedKey) {\n      console.trace(\"Visitor defined for \".concat(_nodeType2, \" but it has been renamed to \").concat(deprecratedKey));\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[_nodeType2];\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = aliases[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var alias = _step3.value;\n        var existing = visitor[alias];\n\n        if (existing) {\n          mergePair(existing, _fns2);\n        } else {\n          visitor[alias] = (0, _clone.default)(_fns2);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {\n    var _nodeType3 = _Object$keys4[_i4];\n    if (shouldIgnoreKey(_nodeType3)) continue;\n    ensureCallbackArrays(visitor[_nodeType3]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {\n    var nodeType = _Object$keys6[_i6];\n\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(\"You gave us a visitor for the node type \".concat(nodeType, \" but it's not a valid type\"));\n    }\n\n    var visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (var _i7 = 0, _Object$keys7 = Object.keys(visitors); _i7 < _Object$keys7.length; _i7++) {\n        var visitorKey = _Object$keys7[_i7];\n\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(\"\".concat(nodeType, \".\").concat(visitorKey), visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + \"\".concat(nodeType, \" that has the invalid property \").concat(visitorKey));\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  var fns = [].concat(val);\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = fns[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var fn = _step4.value;\n\n      if (typeof fn !== \"function\") {\n        throw new TypeError(\"Non-function found defined in \".concat(path, \" with type \").concat(typeof fn));\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction merge(visitors) {\n  var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var wrapper = arguments.length > 2 ? arguments[2] : undefined;\n  var rootVisitor = {};\n\n  for (var i = 0; i < visitors.length; i++) {\n    var visitor = visitors[i];\n    var state = states[i];\n    explode(visitor);\n\n    for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {\n      var type = _Object$keys8[_i8];\n      var visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  var newVisitor = {};\n\n  var _loop = function _loop() {\n    var key = _Object$keys9[_i9];\n    var fns = oldVisitor[key];\n    if (!Array.isArray(fns)) return \"continue\";\n    fns = fns.map(function (fn) {\n      var newFn = fn;\n\n      if (state) {\n        newFn = function newFn(path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  };\n\n  for (var _i9 = 0, _Object$keys9 = Object.keys(oldVisitor); _i9 < _Object$keys9.length; _i9++) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (var _i10 = 0, _Object$keys10 = Object.keys(obj); _i10 < _Object$keys10.length; _i10++) {\n    var key = _Object$keys10[_i10];\n    if (shouldIgnoreKey(key)) continue;\n    var fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  var newFn = function newFn(path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = function () {\n    return fn.toString();\n  };\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"blacklist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (var _i11 = 0, _Object$keys11 = Object.keys(src); _i11 < _Object$keys11.length; _i11++) {\n    var key = _Object$keys11[_i11];\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/core/node_modules/@babel/traverse/lib/visitors.js"],"names":["Object","defineProperty","exports","value","explode","verify","merge","virtualTypes","_interopRequireWildcard","require","t","_clone","_interopRequireDefault","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","visitor","_exploded","keys","nodeType","shouldIgnoreKey","parts","split","length","fns","part","ensureEntranceObjects","ensureCallbackArrays","wrapper","type","wrapCheck","types","mergePair","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","existing","_verified","Error","validateVisitorMethods","TYPES","indexOf","visitors","visitorKey","path","val","concat","fn","TypeError","states","rootVisitor","i","state","visitorType","wrapWithStateOrWrapper","nodeVisitor","oldVisitor","newVisitor","Array","isArray","map","newFn","enter","exit","checkPath","apply","arguments","toString","dest","src"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _clone = _interopRequireDefault(require(\"lodash/clone\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = (0, _clone.default)(fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"blacklist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}"]},"metadata":{},"sourceType":"script"}