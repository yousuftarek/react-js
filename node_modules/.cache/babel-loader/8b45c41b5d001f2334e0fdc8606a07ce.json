{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.minVersion = minVersion;\nexports.getDependencies = getDependencies;\nexports.ensure = ensure;\nexports.default = exports.list = void 0;\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helpers = _interopRequireDefault(require(\"./helpers\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction makePath(path) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nfunction getHelperMetadata(file) {\n  const globals = new Set();\n  const localBindingNames = new Set();\n  const dependencies = new Map();\n  let exportName;\n  let exportPath;\n  const exportBindingAssignments = [];\n  const importPaths = [];\n  const importBindingsReferences = [];\n  (0, _traverse.default)(file, {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (decl.isFunctionDeclaration()) {\n        if (!decl.node.id) {\n          throw decl.buildCodeFrameError(\"Helpers should give names to their exported func declaration\");\n        }\n\n        exportName = decl.node.id.name;\n      }\n\n      exportPath = makePath(child);\n    },\n\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n\n  });\n  (0, _traverse.default)(file, {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name, true);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n\n  });\n  if (!exportPath) throw new Error(\"Helpers must default-export something.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  const localBindingNames = metadata.localBindingNames,\n        dependencies = metadata.dependencies,\n        exportBindingAssignments = metadata.exportBindingAssignments,\n        exportPath = metadata.exportPath,\n        exportName = metadata.exportName,\n        importBindingsReferences = metadata.importBindingsReferences,\n        importPaths = metadata.importPaths;\n  const dependenciesRefs = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  const toRename = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  (0, _traverse.default)(file, {\n    Program(path) {\n      const exp = path.get(exportPath);\n      const imps = importPaths.map(p => path.get(p));\n      const impsBindingRefs = importBindingsReferences.map(p => path.get(p));\n      const decl = exp.get(\"declaration\");\n\n      if (id.type === \"Identifier\") {\n        if (decl.isFunctionDeclaration()) {\n          exp.replaceWith(decl);\n        } else {\n          exp.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(id, decl.node)]));\n        }\n      } else if (id.type === \"MemberExpression\") {\n        if (decl.isFunctionDeclaration()) {\n          exportBindingAssignments.forEach(assignPath => {\n            const assign = path.get(assignPath);\n            assign.replaceWith(t.assignmentExpression(\"=\", id, assign.node));\n          });\n          exp.replaceWith(decl);\n          path.pushContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", id, t.identifier(exportName))));\n        } else {\n          exp.replaceWith(t.expressionStatement(t.assignmentExpression(\"=\", id, decl.node)));\n        }\n      } else {\n        throw new Error(\"Unexpected helper format.\");\n      }\n\n      Object.keys(toRename).forEach(name => {\n        path.scope.rename(name, toRename[name]);\n      });\n\n      for (const path of imps) path.remove();\n\n      for (const path of impsBindingRefs) {\n        const node = t.cloneNode(dependenciesRefs[path.node.name]);\n        path.replaceWith(node);\n      }\n\n      path.stop();\n    }\n\n  });\n}\n\nconst helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    const helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    const fn = () => {\n      return t.file(helper.ast());\n    };\n\n    const metadata = getHelperMetadata(fn());\n    helperData[name] = {\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.program.body,\n          globals: metadata.globals\n        };\n      },\n\n      minVersion() {\n        return helper.minVersion;\n      },\n\n      dependencies: metadata.dependencies\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion();\n}\n\nfunction getDependencies(name) {\n  return Array.from(loadHelper(name).dependencies.values());\n}\n\nfunction ensure(name) {\n  loadHelper(name);\n}\n\nconst list = Object.keys(_helpers.default).map(name => name.replace(/^_/, \"\")).filter(name => name !== \"__esModule\");\nexports.list = list;\nvar _default = get;\nexports.default = _default;","map":{"version":3,"sources":["/home/hyper/Downloads/bookstore/node_modules/@babel/helpers/lib/index.js"],"names":["Object","defineProperty","exports","value","get","minVersion","getDependencies","ensure","default","list","_traverse","_interopRequireDefault","require","t","_interopRequireWildcard","_helpers","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","makePath","path","parts","parentPath","push","inList","listKey","reverse","join","getHelperMetadata","file","globals","Set","localBindingNames","dependencies","Map","exportName","exportPath","exportBindingAssignments","importPaths","importBindingsReferences","ImportDeclaration","child","name","node","source","buildCodeFrameError","length","isImportDefaultSpecifier","bindingIdentifier","specifiers","local","ExportDefaultDeclaration","decl","isFunctionDeclaration","id","ExportAllDeclaration","ExportNamedDeclaration","Statement","isModuleDeclaration","skip","Program","bindings","scope","getAllBindings","keys","forEach","identifier","add","ReferencedIdentifier","binding","getBinding","AssignmentExpression","left","getBindingIdentifiers","isIdentifier","isProgram","Error","Array","from","permuteHelperAST","metadata","localBindings","getDependency","dependenciesRefs","toRename","newName","type","exp","imps","map","p","impsBindingRefs","replaceWith","variableDeclaration","variableDeclarator","assignPath","assign","assignmentExpression","pushContainer","expressionStatement","rename","remove","cloneNode","stop","helperData","create","loadHelper","helper","ReferenceError","code","fn","ast","build","nodes","program","body","values","replace","filter","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.minVersion = minVersion;\nexports.getDependencies = getDependencies;\nexports.ensure = ensure;\nexports.default = exports.list = void 0;\n\nvar _traverse = _interopRequireDefault(require(\"@babel/traverse\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helpers = _interopRequireDefault(require(\"./helpers\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction makePath(path) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nfunction getHelperMetadata(file) {\n  const globals = new Set();\n  const localBindingNames = new Set();\n  const dependencies = new Map();\n  let exportName;\n  let exportPath;\n  const exportBindingAssignments = [];\n  const importPaths = [];\n  const importBindingsReferences = [];\n  (0, _traverse.default)(file, {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (decl.isFunctionDeclaration()) {\n        if (!decl.node.id) {\n          throw decl.buildCodeFrameError(\"Helpers should give names to their exported func declaration\");\n        }\n\n        exportName = decl.node.id.name;\n      }\n\n      exportPath = makePath(child);\n    },\n\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n\n  });\n  (0, _traverse.default)(file, {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name, true);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n\n  });\n  if (!exportPath) throw new Error(\"Helpers must default-export something.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  const {\n    localBindingNames,\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  } = metadata;\n  const dependenciesRefs = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  const toRename = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  (0, _traverse.default)(file, {\n    Program(path) {\n      const exp = path.get(exportPath);\n      const imps = importPaths.map(p => path.get(p));\n      const impsBindingRefs = importBindingsReferences.map(p => path.get(p));\n      const decl = exp.get(\"declaration\");\n\n      if (id.type === \"Identifier\") {\n        if (decl.isFunctionDeclaration()) {\n          exp.replaceWith(decl);\n        } else {\n          exp.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(id, decl.node)]));\n        }\n      } else if (id.type === \"MemberExpression\") {\n        if (decl.isFunctionDeclaration()) {\n          exportBindingAssignments.forEach(assignPath => {\n            const assign = path.get(assignPath);\n            assign.replaceWith(t.assignmentExpression(\"=\", id, assign.node));\n          });\n          exp.replaceWith(decl);\n          path.pushContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", id, t.identifier(exportName))));\n        } else {\n          exp.replaceWith(t.expressionStatement(t.assignmentExpression(\"=\", id, decl.node)));\n        }\n      } else {\n        throw new Error(\"Unexpected helper format.\");\n      }\n\n      Object.keys(toRename).forEach(name => {\n        path.scope.rename(name, toRename[name]);\n      });\n\n      for (const path of imps) path.remove();\n\n      for (const path of impsBindingRefs) {\n        const node = t.cloneNode(dependenciesRefs[path.node.name]);\n        path.replaceWith(node);\n      }\n\n      path.stop();\n    }\n\n  });\n}\n\nconst helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    const helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    const fn = () => {\n      return t.file(helper.ast());\n    };\n\n    const metadata = getHelperMetadata(fn());\n    helperData[name] = {\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.program.body,\n          globals: metadata.globals\n        };\n      },\n\n      minVersion() {\n        return helper.minVersion;\n      },\n\n      dependencies: metadata.dependencies\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion();\n}\n\nfunction getDependencies(name) {\n  return Array.from(loadHelper(name).dependencies.values());\n}\n\nfunction ensure(name) {\n  loadHelper(name);\n}\n\nconst list = Object.keys(_helpers.default).map(name => name.replace(/^_/, \"\")).filter(name => name !== \"__esModule\");\nexports.list = list;\nvar _default = get;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}