{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nvar VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nvar INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  var res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  var node = path.node;\n  var seen = state.seen;\n\n  if (seen.has(node)) {\n    var existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    var item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    var val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  var node = path.node;\n\n  if (path.isSequenceExpression()) {\n    var exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    var object = path.get(\"tag.object\");\n    var name = object.node.name;\n    var property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    var testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    var _property = path.get(\"property\");\n\n    var _object = path.get(\"object\");\n\n    if (_object.isLiteral() && _property.isIdentifier()) {\n      var value = _object.node.value;\n      var type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[_property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    var binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      var resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    var argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    var arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    var arr = [];\n    var elems = path.get(\"elements\");\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = elems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var elem = _step.value;\n        var elemValue = elem.evaluate();\n\n        if (elemValue.confident) {\n          arr.push(elemValue.value);\n        } else {\n          return deopt(elem, state);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    var obj = {};\n    var props = path.get(\"properties\");\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = props[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var prop = _step2.value;\n\n        if (prop.isObjectMethod() || prop.isSpreadElement()) {\n          return deopt(prop, state);\n        }\n\n        var keyPath = prop.get(\"key\");\n        var key = keyPath;\n\n        if (prop.node.computed) {\n          key = key.evaluate();\n\n          if (!key.confident) {\n            return deopt(keyPath, state);\n          }\n\n          key = key.value;\n        } else if (key.isIdentifier()) {\n          key = key.node.name;\n        } else {\n          key = key.node.value;\n        }\n\n        var valuePath = prop.get(\"value\");\n\n        var _value = valuePath.evaluate();\n\n        if (!_value.confident) {\n          return deopt(valuePath, state);\n        }\n\n        _value = _value.value;\n        obj[key] = _value;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    var wasConfident = state.confident;\n    var left = evaluateCached(path.get(\"left\"), state);\n    var leftConfident = state.confident;\n    state.confident = wasConfident;\n    var right = evaluateCached(path.get(\"right\"), state);\n    var rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    var _left = evaluateCached(path.get(\"left\"), state);\n\n    if (!state.confident) return;\n\n    var _right = evaluateCached(path.get(\"right\"), state);\n\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return _left - _right;\n\n      case \"+\":\n        return _left + _right;\n\n      case \"/\":\n        return _left / _right;\n\n      case \"*\":\n        return _left * _right;\n\n      case \"%\":\n        return _left % _right;\n\n      case \"**\":\n        return Math.pow(_left, _right);\n\n      case \"<\":\n        return _left < _right;\n\n      case \">\":\n        return _left > _right;\n\n      case \"<=\":\n        return _left <= _right;\n\n      case \">=\":\n        return _left >= _right;\n\n      case \"==\":\n        return _left == _right;\n\n      case \"!=\":\n        return _left != _right;\n\n      case \"===\":\n        return _left === _right;\n\n      case \"!==\":\n        return _left !== _right;\n\n      case \"|\":\n        return _left | _right;\n\n      case \"&\":\n        return _left & _right;\n\n      case \"^\":\n        return _left ^ _right;\n\n      case \"<<\":\n        return _left << _right;\n\n      case \">>\":\n        return _left >> _right;\n\n      case \">>>\":\n        return _left >>> _right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    var callee = path.get(\"callee\");\n    var context;\n    var func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      var _object2 = callee.get(\"object\");\n\n      var _property2 = callee.get(\"property\");\n\n      if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {\n        context = global[_object2.node.name];\n        func = context[_property2.node.name];\n      }\n\n      if (_object2.isLiteral() && _property2.isIdentifier()) {\n        var _type = typeof _object2.node.value;\n\n        if (_type === \"string\" || _type === \"number\") {\n          context = _object2.node.value;\n          func = context[_property2.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      var args = path.get(\"arguments\").map(function (arg) {\n        return evaluateCached(arg, state);\n      });\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state) {\n  var raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var str = \"\";\n  var i = 0;\n  var exprs = path.get(\"expressions\");\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = quasis[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var elem = _step3.value;\n      if (!state.confident) break;\n      str += raw ? elem.value.raw : elem.value.cooked;\n      var expr = exprs[i++];\n      if (expr) str += String(evaluateCached(expr, state));\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  var state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  var value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/evaluation.js"],"names":["Object","defineProperty","exports","value","evaluateTruthy","evaluate","VALID_CALLEES","INVALID_METHODS","res","confident","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","val","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","indexOf","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  const {\n    node\n  } = path;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elem, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(keyPath, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(valuePath, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}"]},"metadata":{},"sourceType":"script"}