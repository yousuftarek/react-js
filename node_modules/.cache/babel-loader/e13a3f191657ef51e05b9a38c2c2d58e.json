{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","map":{"version":3,"sources":["/home/gronthik/Downloads/gronthik.com/gronthikfrontend/bookstore/node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"],"names":["Object","defineProperty","exports","value","default","_default","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","voidTypeAnnotation","numberTypeAnnotation","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","concat","violation","getTypeAnnotation","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","isFunction","test","paths","i","isLogicalExpression","isBinaryExpression","type"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}"]},"metadata":{},"sourceType":"script"}