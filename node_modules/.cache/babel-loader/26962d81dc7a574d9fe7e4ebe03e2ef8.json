{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const node = path.node,\n          parent = path.parent;\n\n    if (!t().isIdentifier(node, opts) && !t().isJSXMemberExpression(parent, opts)) {\n      if (t().isJSXIdentifier(node, opts)) {\n        if (t().react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t().isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t().isMemberExpression(node) && t().isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const node = path.node,\n          parent = path.parent;\n    const grandparent = path.parentPath.parent;\n    return t().isIdentifier(node) && t().isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t().isStatement(node)) {\n      if (t().isVariableDeclaration(node)) {\n        if (t().isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t().isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t().isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\"],\n\n  checkPath(path) {\n    return t().isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t().isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t().isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t().isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t().isFlow(node)) {\n      return true;\n    } else if (t().isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t().isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t().isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","t","data","_interopRequireWildcard","require","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","default","types","checkPath","path","opts","node","parent","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","parentPath","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","scope","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t().isIdentifier(node, opts) && !t().isJSXMemberExpression(parent, opts)) {\n      if (t().isJSXIdentifier(node, opts)) {\n        if (t().react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t().isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t().isMemberExpression(node) && t().isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t().isIdentifier(node) && t().isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t().isStatement(node)) {\n      if (t().isVariableDeclaration(node)) {\n        if (t().isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t().isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t().isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\"],\n\n  checkPath(path) {\n    return t().isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t().isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t().isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t().isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t().isFlow(node)) {\n      return true;\n    } else if (t().isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t().isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t().isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}