{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.NewExpression = NewExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent) || t.isMemberExpression(parent);\n}\n\nfunction AssignmentExpression(node) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(...arguments);\n  }\n}\n\nfunction NewExpression(node, parent) {\n  return isClassExtendsClause(node, parent);\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (t.isCallExpression(parent, {\n      callee: node\n    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {\n      object: node\n    }) || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/hyper/Downloads/bookstore/node_modules/@babel/helpers/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","NullableTypeAnnotation","FunctionTypeAnnotation","UpdateExpression","ObjectExpression","DoExpression","Binary","IntersectionTypeAnnotation","UnionTypeAnnotation","TSAsExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","BinaryExpression","SequenceExpression","AwaitExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","NewExpression","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","isClassDeclaration","isClassExpression","superClass","isArrayTypeAnnotation","printStack","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","length","isMemberExpression","object","isCallExpression","callee","isNewExpression","isFirstInStatement","considerArrow","operator","isBinaryExpression","left","isUnaryLike","isAwaitExpression","isBinary","parentOp","parentPos","nodeOp","nodePos","right","isLogicalExpression","isNullableTypeAnnotation","isTSArrayType","isTSOptionalType","isTSIntersectionType","isTSUnionType","isTSRestType","isVariableDeclarator","isFor","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","test","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","isExpressionStatement","expression","isYieldExpression","isConditionalExpression","considerDefaultExports","isExportDeclaration","isOptionalMemberExpression","isTaggedTemplateExpression","isTSTypeAssertion","isTSAsExpression","isObjectPattern","arguments","i","isExportDefaultDeclaration","declaration","body","isSequenceExpression","expressions","isConditional","isAssignmentExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.NewExpression = NewExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isOptionalMemberExpression(parent) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent) || t.isMemberExpression(parent);\n}\n\nfunction AssignmentExpression(node) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(...arguments);\n  }\n}\n\nfunction NewExpression(node, parent) {\n  return isClassExtendsClause(node, parent);\n}\n\nfunction isFirstInStatement(printStack, {\n  considerArrow = false,\n  considerDefaultExports = false\n} = {}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (t.isCallExpression(parent, {\n      callee: node\n    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {\n      object: node\n    }) || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}