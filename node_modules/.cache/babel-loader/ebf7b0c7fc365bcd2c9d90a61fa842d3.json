{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // external dependencies\n\n\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport { createElementRef, createMethod } from 'react-parm'; // blob\n\nimport { createGetCachedLinkHref, hasBlobSupport } from './blob'; // constants\n\nimport { SUPPORTS_BEFORE_UPDATE_SNAPSHOT } from './constants'; // options\n\nimport { getCoalescedOption, setGlobalOptions } from './options'; // styles\n\nimport { getRenderedStyles } from './styles';\n/**\n * @function componentDidMount\n *\n * @description\n * on mount, relocate the node\n *\n * @param {ReactComponent} instance the component instance\n * @param {HTMLElement} instance.node the node to render the styles into\n * @param {function} instance.relocateNote the method to relocate the node to the head\n * @returns {void}\n */\n\nexport var componentDidMount = function componentDidMount(_ref) {\n  var node = _ref.node,\n      relocateNode = _ref.relocateNode;\n  return relocateNode(node);\n};\n/**\n * @function getSnapshotBeforeUpdate\n *\n * @description\n * before the update occurs, if the sourceMap requirements have changed, return the node to its original position\n *\n * @param {ReactComponent} instance the component instance\n * @param {HTMLElement} instance.node the node to render the styles into\n * @param {function} instance.returnNode the method to return the node to its original parent\n * @returns {null}\n */\n\nexport var getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(_ref2) {\n  var node = _ref2.node,\n      returnNode = _ref2.returnNode;\n  returnNode(node);\n  return null;\n};\n/**\n * @function componentDidUpdate\n *\n * @description\n * on update, if the sourceMap requirements have changed then relocate the new node to the head,\n * and if the styles have changed then set them in staet\n *\n * @param {ReactComponent} instance the component instance\n * @param {function} instance.getStyleForState the method to get the new rendered style\n * @param {HTMLElement} instance.node the node to render the styles into\n * @param {function} instance.relocateNote the method to relocate the node to the head\n * @param {Object} instance.props the new props of the component\n * @param {function} instance.setState the method to set the state of the component\n * @param {Array<any>} args the arguments passed to the function\n * @param {Object} previousProps the previous props of the component\n */\n\nexport var componentDidUpdate = function componentDidUpdate(_ref3, _ref4) {\n  var getStyleForState = _ref3.getStyleForState,\n      node = _ref3.node,\n      relocateNode = _ref3.relocateNode,\n      props = _ref3.props,\n      setState = _ref3.setState;\n  var previousProps = _ref4[0];\n  relocateNode(node);\n\n  if (props.children !== previousProps.children) {\n    setState(getStyleForState);\n  }\n};\n/**\n * @function componentWillUnmount\n *\n * @description\n * prior to unmount, return the node to its original parent\n *\n * @param {ReactComponent} instance the component instance\n * @param {HTMLElement} instance.node the node to render the styles into\n * @param {function} instance.returnNode the method to return the node to its original parent\n * @returns {void}\n */\n\nexport var componentWillUnmount = function componentWillUnmount(_ref5) {\n  var node = _ref5.node,\n      returnNode = _ref5.returnNode;\n  return returnNode(node);\n};\n/**\n * @function getStyleForState\n *\n * @description\n * get the styles to be used for the rendered tag\n *\n * @param {ReactComponent} instance the component instance\n * @param {Object} instance.props the new props of the component\n * @returns {{style: string}} the style strng to use in the rendered tag\n */\n\nexport var getStyleForState = function getStyleForState(_ref6) {\n  var props = _ref6.props;\n  return {\n    style: getRenderedStyles(props.children, {\n      isCompressed: getCoalescedOption(props, 'isCompressed'),\n      isMinified: getCoalescedOption(props, 'isMinified'),\n      isPrefixed: getCoalescedOption(props, 'isPrefixed')\n    })\n  };\n};\n/**\n * @function relocateNode\n *\n * @description\n * relocate the node to the bottom of the head\n *\n * @param {ReactComponent} instance the component instance\n * @param {Array<any>} args the arguments passed to the function\n * @param {HTMLElement} node the node to render the styles into\n */\n\nexport var relocateNode = function relocateNode(instance, _ref7) {\n  var node = _ref7[0];\n\n  if (typeof document !== 'undefined' && node) {\n    instance.originalParent = node.parentNode;\n    instance.originalParent.removeChild(node);\n    document.head.appendChild(node);\n  }\n};\n/**\n * @function returnNode\n *\n * @description\n * return the node to the original parent\n *\n * @param {ReactComponent} instance the component instance\n * @param {Array<any>} args the arguments passed to the function\n * @param {HTMLElement} node the node to render the styles into\n */\n\nexport var returnNode = function returnNode(instance, _ref8) {\n  var node = _ref8[0];\n\n  if (typeof document !== 'undefined' && node) {\n    try {\n      document.head.removeChild(node);\n      instance.originalParent.appendChild(node);\n    } catch (error) {// ignore the error\n    } finally {\n      instance.node = null;\n      instance.originalParent = null;\n    }\n  }\n};\n\nvar Style = function (_PureComponent) {\n  _inherits(Style, _PureComponent);\n\n  function Style(props) {\n    _classCallCheck(this, Style);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _this.componentDidMount = createMethod(_this, componentDidMount);\n    _this.componentDidUpdate = createMethod(_this, componentDidUpdate);\n    _this[SUPPORTS_BEFORE_UPDATE_SNAPSHOT ? 'getSnapshotBeforeUpdate' : 'componentWillUpdate'] = createMethod(_this, getSnapshotBeforeUpdate);\n    _this.componentWillUnmount = createMethod(_this, componentWillUnmount);\n    _this.linkHref = null;\n    _this.node = null;\n    _this.originalParent = null;\n    _this.getCachedLinkHref = createGetCachedLinkHref();\n    _this.getStyleForState = createMethod(_this, getStyleForState);\n    _this.relocateNode = createMethod(_this, relocateNode);\n    _this.returnNode = createMethod(_this, returnNode);\n    _this.state = getStyleForState({\n      props: props\n    });\n    return _this;\n  } // lifecycle methods\n\n  /* eslint-disable react/sort-comp */\n\n  /* eslint-enable */\n  // instance values\n  // static methods\n  // instance methods\n\n\n  Style.prototype.render = function render() {\n    var _props = this.props,\n        childrenIgnored = _props.children,\n        hasSourceMapIgnored = _props.hasSourceMap,\n        isMinifiedIgnored = _props.isCompressed,\n        isPrefixedIgnored = _props.isPrefixed,\n        props = _objectWithoutProperties(_props, ['children', 'hasSourceMap', 'isCompressed', 'isPrefixed']);\n\n    var style = this.state.style;\n\n    if (getCoalescedOption(this.props, 'hasSourceMap')) {\n      if (hasBlobSupport()) {\n        return (\n          /* eslint-disable prettier */\n          React.createElement('link', _extends({}, props, {\n            href: this.getCachedLinkHref(style),\n            ref: createElementRef(this, 'node'),\n            rel: 'stylesheet'\n          }))\n          /* eslint-enable */\n\n        );\n      }\n      /* eslint-disable no-console */\n\n\n      console.error('To support sourcemaps for react-style-tag you need Blob support, and the browser you are using does not currently support it. You should include a polyfill prior to the rendering of this component.');\n      /* eslint-enable */\n    }\n\n    return React.createElement('style', _extends({\n      ref: createElementRef(this, 'node')\n    }, props), style);\n  };\n\n  return Style;\n}(PureComponent);\n\nStyle.propTypes = {\n  children: PropTypes.string.isRequired,\n  hasSourceMap: PropTypes.bool,\n  id: PropTypes.string,\n  isCompressed: PropTypes.bool,\n  isMinified: PropTypes.bool,\n  isPrefixed: PropTypes.bool\n};\nStyle.setGlobalOptions = setGlobalOptions;\nexport default Style;","map":null,"metadata":{},"sourceType":"module"}