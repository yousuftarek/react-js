{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  var parentPath = this.parentPath;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  var _this$container;\n\n  this.updateSiblingKeys(from, nodes.length);\n  var paths = [];\n\n  (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(_toConsumableArray(nodes)));\n\n  for (var i = 0; i < nodes.length; i++) {\n    var to = from + i;\n    var path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  var contexts = this._getQueueContexts();\n\n  for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {\n    var _path = _paths[_i];\n\n    _path.setScope();\n\n    _path.debug(\"Inserted.\");\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = contexts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var context = _step.value;\n        context.maybeQueue(_path, true);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  var parentPath = this.parentPath;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(function (node) {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      var scope = this.scope;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      var temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  var paths = _cache.path.get(this.parent);\n\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var msg = void 0;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      var type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\"Node list \".concat(msg, \" with the index of \").concat(i, \" and type of \").concat(type));\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  var path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey: listKey,\n    key: 0\n  });\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  var container = this.node[listKey];\n\n  var path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: container.length\n  });\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist() {\n  var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  var hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/helpers/node_modules/@babel/traverse/lib/path/modification.js"],"names":["Object","defineProperty","exports","value","insertBefore","_containerInsert","_containerInsertBefore","_containerInsertAfter","insertAfter","updateSiblingKeys","_verifyNodeList","unshiftContainer","pushContainer","hoist","_cache","require","_hoister","_interopRequireDefault","_index","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","nodes","_assertUnremoved","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","node","push","replaceExpressionWithStatements","Array","isArray","container","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","blockStatement","Error","from","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","map","isExpression","expressionStatement","scope","isMethod","computed","parent","temp","generateDeclaredUidIdentifier","unshift","assignmentExpression","cloneNode","fromIndex","incrementBy","constructor","msg","type","listKey","replaceWithMultiple","hoister","run"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      let {\n        scope\n      } = this;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  });\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  });\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"]},"metadata":{},"sourceType":"script"}