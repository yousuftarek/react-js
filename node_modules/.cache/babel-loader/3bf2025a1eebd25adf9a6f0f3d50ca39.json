{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _defaults = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction gatherNodeParts(node, parts) {\n  if (t.isModuleDeclaration(node)) {\n    if (node.source) {\n      gatherNodeParts(node.source, parts);\n    } else if (node.specifiers && node.specifiers.length) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = node.specifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var specifier = _step.value;\n          gatherNodeParts(specifier, parts);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } else if (node.declaration) {\n      gatherNodeParts(node.declaration, parts);\n    }\n  } else if (t.isModuleSpecifier(node)) {\n    gatherNodeParts(node.local, parts);\n  } else if (t.isMemberExpression(node)) {\n    gatherNodeParts(node.object, parts);\n    gatherNodeParts(node.property, parts);\n  } else if (t.isIdentifier(node)) {\n    parts.push(node.name);\n  } else if (t.isLiteral(node)) {\n    parts.push(node.value);\n  } else if (t.isCallExpression(node)) {\n    gatherNodeParts(node.callee, parts);\n  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var prop = _step2.value;\n        gatherNodeParts(prop.key || prop.argument, parts);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } else if (t.isPrivateName(node)) {\n    gatherNodeParts(node.id, parts);\n  } else if (t.isThisExpression(node)) {\n    parts.push(\"this\");\n  } else if (t.isSuper(node)) {\n    parts.push(\"super\");\n  }\n}\n\nvar collectorVisitor = {\n  For: function For(path) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = t.FOR_INIT_KEYS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var key = _step3.value;\n        var declar = path.get(key);\n\n        if (declar.isVar()) {\n          var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n          parentScope.registerBinding(\"var\", declar);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  },\n  Declaration: function Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n  ForXStatement: function ForXStatement(path, state) {\n    var left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n  ExportDeclaration: {\n    exit: function exit(path) {\n      var node = path.node,\n          scope = path.scope;\n      var declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        var id = declar.id;\n        if (!id) return;\n        var binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = declar.declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var decl = _step4.value;\n\n            for (var _i = 0, _Object$keys = Object.keys(t.getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {\n              var name = _Object$keys[_i];\n\n              var _binding2 = scope.getBinding(name);\n\n              if (_binding2) _binding2.reference(path);\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n    }\n  },\n  LabeledStatement: function LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression: function AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression: function UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression: function UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped: function BlockScoped(path) {\n    var scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    scope.getBlockParent().registerDeclaration(path);\n  },\n  ClassDeclaration: function ClassDeclaration(path) {\n    var id = path.node.id;\n    if (!id) return;\n    var name = id.name;\n    path.scope.bindings[name] = path.scope.getBinding(name);\n  },\n  Block: function Block(path) {\n    var paths = path.get(\"body\");\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = paths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var bodyPath = _step5.value;\n\n        if (bodyPath.isFunctionDeclaration()) {\n          path.scope.getBlockParent().registerDeclaration(bodyPath);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  }\n};\nvar uid = 0;\n\nvar Scope =\n/*#__PURE__*/\nfunction () {\n  function Scope(path) {\n    _classCallCheck(this, Scope);\n\n    var node = path.node;\n\n    var cached = _cache.scope.get(node);\n\n    if (cached && cached.path === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n  }\n\n  _createClass(Scope, [{\n    key: \"traverse\",\n    value: function traverse(node, opts, state) {\n      (0, _index.default)(node, opts, this, state, this.path);\n    }\n  }, {\n    key: \"generateDeclaredUidIdentifier\",\n    value: function generateDeclaredUidIdentifier(name) {\n      var id = this.generateUidIdentifier(name);\n      this.push({\n        id: id\n      });\n      return t.cloneNode(id);\n    }\n  }, {\n    key: \"generateUidIdentifier\",\n    value: function generateUidIdentifier(name) {\n      return t.identifier(this.generateUid(name));\n    }\n  }, {\n    key: \"generateUid\",\n    value: function generateUid() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n      name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n      var uid;\n      var i = 0;\n\n      do {\n        uid = this._generateUid(name, i);\n        i++;\n      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n      var program = this.getProgramParent();\n      program.references[uid] = true;\n      program.uids[uid] = true;\n      return uid;\n    }\n  }, {\n    key: \"_generateUid\",\n    value: function _generateUid(name, i) {\n      var id = name;\n      if (i > 1) id += i;\n      return \"_\".concat(id);\n    }\n  }, {\n    key: \"generateUidBasedOnNode\",\n    value: function generateUidBasedOnNode(parent, defaultName) {\n      var node = parent;\n\n      if (t.isAssignmentExpression(parent)) {\n        node = parent.left;\n      } else if (t.isVariableDeclarator(parent)) {\n        node = parent.id;\n      } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {\n        node = node.key;\n      }\n\n      var parts = [];\n      gatherNodeParts(node, parts);\n      var id = parts.join(\"$\");\n      id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n      return this.generateUid(id.slice(0, 20));\n    }\n  }, {\n    key: \"generateUidIdentifierBasedOnNode\",\n    value: function generateUidIdentifierBasedOnNode(parent, defaultName) {\n      return t.identifier(this.generateUidBasedOnNode(parent, defaultName));\n    }\n  }, {\n    key: \"isStatic\",\n    value: function isStatic(node) {\n      if (t.isThisExpression(node) || t.isSuper(node)) {\n        return true;\n      }\n\n      if (t.isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n\n        if (binding) {\n          return binding.constant;\n        } else {\n          return this.hasBinding(node.name);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"maybeGenerateMemoised\",\n    value: function maybeGenerateMemoised(node, dontPush) {\n      if (this.isStatic(node)) {\n        return null;\n      } else {\n        var id = this.generateUidIdentifierBasedOnNode(node);\n\n        if (!dontPush) {\n          this.push({\n            id: id\n          });\n          return t.cloneNode(id);\n        }\n\n        return id;\n      }\n    }\n  }, {\n    key: \"checkBlockScopedCollisions\",\n    value: function checkBlockScopedCollisions(local, kind, name, id) {\n      if (kind === \"param\") return;\n      if (local.kind === \"local\") return;\n      var duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n      if (duplicate) {\n        throw this.hub.buildError(id, \"Duplicate declaration \\\"\".concat(name, \"\\\"\"), TypeError);\n      }\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(oldName, newName, block) {\n      var binding = this.getBinding(oldName);\n\n      if (binding) {\n        newName = newName || this.generateUidIdentifier(oldName).name;\n        return new _renamer.default(binding, oldName, newName).rename(block);\n      }\n    }\n  }, {\n    key: \"_renameFromMap\",\n    value: function _renameFromMap(map, oldName, newName, value) {\n      if (map[oldName]) {\n        map[newName] = value;\n        map[oldName] = null;\n      }\n    }\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      var sep = (0, _repeat.default)(\"-\", 60);\n      console.log(sep);\n      var scope = this;\n\n      do {\n        console.log(\"#\", scope.block.type);\n\n        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {\n          var name = _Object$keys2[_i2];\n          var binding = scope.bindings[name];\n          console.log(\" -\", name, {\n            constant: binding.constant,\n            references: binding.references,\n            violations: binding.constantViolations.length,\n            kind: binding.kind\n          });\n        }\n      } while (scope = scope.parent);\n\n      console.log(sep);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(node, i) {\n      if (t.isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n\n        if (binding && binding.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n\n      if (t.isArrayExpression(node)) {\n        return node;\n      }\n\n      if (t.isIdentifier(node, {\n        name: \"arguments\"\n      })) {\n        return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n      }\n\n      var helperName;\n      var args = [node];\n\n      if (i === true) {\n        helperName = \"toConsumableArray\";\n      } else if (i) {\n        args.push(t.numericLiteral(i));\n        helperName = \"slicedToArray\";\n      } else {\n        helperName = \"toArray\";\n      }\n\n      return t.callExpression(this.hub.addHelper(helperName), args);\n    }\n  }, {\n    key: \"hasLabel\",\n    value: function hasLabel(name) {\n      return !!this.getLabel(name);\n    }\n  }, {\n    key: \"getLabel\",\n    value: function getLabel(name) {\n      return this.labels.get(name);\n    }\n  }, {\n    key: \"registerLabel\",\n    value: function registerLabel(path) {\n      this.labels.set(path.node.label.name, path);\n    }\n  }, {\n    key: \"registerDeclaration\",\n    value: function registerDeclaration(path) {\n      if (path.isLabeledStatement()) {\n        this.registerLabel(path);\n      } else if (path.isFunctionDeclaration()) {\n        this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n      } else if (path.isVariableDeclaration()) {\n        var declarations = path.get(\"declarations\");\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = declarations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var declar = _step6.value;\n            this.registerBinding(path.node.kind, declar);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      } else if (path.isClassDeclaration()) {\n        this.registerBinding(\"let\", path);\n      } else if (path.isImportDeclaration()) {\n        var specifiers = path.get(\"specifiers\");\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = specifiers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var specifier = _step7.value;\n            this.registerBinding(\"module\", specifier);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      } else if (path.isExportDeclaration()) {\n        var _declar = path.get(\"declaration\");\n\n        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {\n          this.registerDeclaration(_declar);\n        }\n      } else {\n        this.registerBinding(\"unknown\", path);\n      }\n    }\n  }, {\n    key: \"buildUndefinedNode\",\n    value: function buildUndefinedNode() {\n      return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n    }\n  }, {\n    key: \"registerConstantViolation\",\n    value: function registerConstantViolation(path) {\n      var ids = path.getBindingIdentifiers();\n\n      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {\n        var name = _Object$keys3[_i3];\n        var binding = this.getBinding(name);\n        if (binding) binding.reassign(path);\n      }\n    }\n  }, {\n    key: \"registerBinding\",\n    value: function registerBinding(kind, path) {\n      var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n      if (!kind) throw new ReferenceError(\"no `kind`\");\n\n      if (path.isVariableDeclaration()) {\n        var declarators = path.get(\"declarations\");\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = declarators[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var declar = _step8.value;\n            this.registerBinding(kind, declar);\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        return;\n      }\n\n      var parent = this.getProgramParent();\n      var ids = path.getOuterBindingIdentifiers(true);\n\n      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {\n        var name = _Object$keys4[_i4];\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = ids[name][Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var id = _step9.value;\n            var local = this.getOwnBinding(name);\n\n            if (local) {\n              if (local.identifier === id) continue;\n              this.checkBlockScopedCollisions(local, kind, name, id);\n            }\n\n            parent.references[name] = true;\n\n            if (local) {\n              this.registerConstantViolation(bindingPath);\n            } else {\n              this.bindings[name] = new _binding.default({\n                identifier: id,\n                scope: this,\n                path: bindingPath,\n                kind: kind\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n              _iterator9.return();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"addGlobal\",\n    value: function addGlobal(node) {\n      this.globals[node.name] = node;\n    }\n  }, {\n    key: \"hasUid\",\n    value: function hasUid(name) {\n      var scope = this;\n\n      do {\n        if (scope.uids[name]) return true;\n      } while (scope = scope.parent);\n\n      return false;\n    }\n  }, {\n    key: \"hasGlobal\",\n    value: function hasGlobal(name) {\n      var scope = this;\n\n      do {\n        if (scope.globals[name]) return true;\n      } while (scope = scope.parent);\n\n      return false;\n    }\n  }, {\n    key: \"hasReference\",\n    value: function hasReference(name) {\n      var scope = this;\n\n      do {\n        if (scope.references[name]) return true;\n      } while (scope = scope.parent);\n\n      return false;\n    }\n  }, {\n    key: \"isPure\",\n    value: function isPure(node, constantsOnly) {\n      if (t.isIdentifier(node)) {\n        var binding = this.getBinding(node.name);\n        if (!binding) return false;\n        if (constantsOnly) return binding.constant;\n        return true;\n      } else if (t.isClass(node)) {\n        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n          return false;\n        }\n\n        return this.isPure(node.body, constantsOnly);\n      } else if (t.isClassBody(node)) {\n        var _iteratorNormalCompletion10 = true;\n        var _didIteratorError10 = false;\n        var _iteratorError10 = undefined;\n\n        try {\n          for (var _iterator10 = node.body[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n            var method = _step10.value;\n            if (!this.isPure(method, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _didIteratorError10 = true;\n          _iteratorError10 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n              _iterator10.return();\n            }\n          } finally {\n            if (_didIteratorError10) {\n              throw _iteratorError10;\n            }\n          }\n        }\n\n        return true;\n      } else if (t.isBinary(node)) {\n        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n      } else if (t.isArrayExpression(node)) {\n        var _iteratorNormalCompletion11 = true;\n        var _didIteratorError11 = false;\n        var _iteratorError11 = undefined;\n\n        try {\n          for (var _iterator11 = node.elements[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n            var elem = _step11.value;\n            if (!this.isPure(elem, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _didIteratorError11 = true;\n          _iteratorError11 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n              _iterator11.return();\n            }\n          } finally {\n            if (_didIteratorError11) {\n              throw _iteratorError11;\n            }\n          }\n        }\n\n        return true;\n      } else if (t.isObjectExpression(node)) {\n        var _iteratorNormalCompletion12 = true;\n        var _didIteratorError12 = false;\n        var _iteratorError12 = undefined;\n\n        try {\n          for (var _iterator12 = node.properties[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n            var prop = _step12.value;\n            if (!this.isPure(prop, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _didIteratorError12 = true;\n          _iteratorError12 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n              _iterator12.return();\n            }\n          } finally {\n            if (_didIteratorError12) {\n              throw _iteratorError12;\n            }\n          }\n        }\n\n        return true;\n      } else if (t.isClassMethod(node)) {\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        if (node.kind === \"get\" || node.kind === \"set\") return false;\n        return true;\n      } else if (t.isProperty(node)) {\n        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n        return this.isPure(node.value, constantsOnly);\n      } else if (t.isUnaryExpression(node)) {\n        return this.isPure(node.argument, constantsOnly);\n      } else if (t.isTaggedTemplateExpression(node)) {\n        return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n      } else if (t.isTemplateLiteral(node)) {\n        var _iteratorNormalCompletion13 = true;\n        var _didIteratorError13 = false;\n        var _iteratorError13 = undefined;\n\n        try {\n          for (var _iterator13 = node.expressions[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n            var expression = _step13.value;\n            if (!this.isPure(expression, constantsOnly)) return false;\n          }\n        } catch (err) {\n          _didIteratorError13 = true;\n          _iteratorError13 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n              _iterator13.return();\n            }\n          } finally {\n            if (_didIteratorError13) {\n              throw _iteratorError13;\n            }\n          }\n        }\n\n        return true;\n      } else {\n        return t.isPureish(node);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(key, val) {\n      return this.data[key] = val;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(key) {\n      var scope = this;\n\n      do {\n        var data = scope.data[key];\n        if (data != null) return data;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"removeData\",\n    value: function removeData(key) {\n      var scope = this;\n\n      do {\n        var data = scope.data[key];\n        if (data != null) scope.data[key] = null;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      if (!this.references) this.crawl();\n    }\n  }, {\n    key: \"crawl\",\n    value: function crawl() {\n      var path = this.path;\n      this.references = Object.create(null);\n      this.bindings = Object.create(null);\n      this.globals = Object.create(null);\n      this.uids = Object.create(null);\n      this.data = Object.create(null);\n\n      if (path.isLoop()) {\n        var _iteratorNormalCompletion14 = true;\n        var _didIteratorError14 = false;\n        var _iteratorError14 = undefined;\n\n        try {\n          for (var _iterator14 = t.FOR_INIT_KEYS[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n            var key = _step14.value;\n            var node = path.get(key);\n            if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n          }\n        } catch (err) {\n          _didIteratorError14 = true;\n          _iteratorError14 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n              _iterator14.return();\n            }\n          } finally {\n            if (_didIteratorError14) {\n              throw _iteratorError14;\n            }\n          }\n        }\n      }\n\n      if (path.isFunctionExpression() && path.has(\"id\")) {\n        if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n          this.registerBinding(\"local\", path.get(\"id\"), path);\n        }\n      }\n\n      if (path.isClassExpression() && path.has(\"id\")) {\n        if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n          this.registerBinding(\"local\", path);\n        }\n      }\n\n      if (path.isFunction()) {\n        var params = path.get(\"params\");\n        var _iteratorNormalCompletion15 = true;\n        var _didIteratorError15 = false;\n        var _iteratorError15 = undefined;\n\n        try {\n          for (var _iterator15 = params[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n            var param = _step15.value;\n            this.registerBinding(\"param\", param);\n          }\n        } catch (err) {\n          _didIteratorError15 = true;\n          _iteratorError15 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n              _iterator15.return();\n            }\n          } finally {\n            if (_didIteratorError15) {\n              throw _iteratorError15;\n            }\n          }\n        }\n      }\n\n      if (path.isCatchClause()) {\n        this.registerBinding(\"let\", path);\n      }\n\n      var parent = this.getProgramParent();\n      if (parent.crawling) return;\n      var state = {\n        references: [],\n        constantViolations: [],\n        assignments: []\n      };\n      this.crawling = true;\n      path.traverse(collectorVisitor, state);\n      this.crawling = false;\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = state.assignments[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var _path = _step16.value;\n\n          var ids = _path.getBindingIdentifiers();\n\n          var programParent = void 0;\n\n          for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {\n            var name = _Object$keys5[_i5];\n            if (_path.scope.getBinding(name)) continue;\n            programParent = programParent || _path.scope.getProgramParent();\n            programParent.addGlobal(ids[name]);\n          }\n\n          _path.scope.registerConstantViolation(_path);\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion17 = true;\n      var _didIteratorError17 = false;\n      var _iteratorError17 = undefined;\n\n      try {\n        for (var _iterator17 = state.references[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n          var ref = _step17.value;\n          var binding = ref.scope.getBinding(ref.node.name);\n\n          if (binding) {\n            binding.reference(ref);\n          } else {\n            ref.scope.getProgramParent().addGlobal(ref.node);\n          }\n        }\n      } catch (err) {\n        _didIteratorError17 = true;\n        _iteratorError17 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n            _iterator17.return();\n          }\n        } finally {\n          if (_didIteratorError17) {\n            throw _iteratorError17;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion18 = true;\n      var _didIteratorError18 = false;\n      var _iteratorError18 = undefined;\n\n      try {\n        for (var _iterator18 = state.constantViolations[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n          var _path2 = _step18.value;\n\n          _path2.scope.registerConstantViolation(_path2);\n        }\n      } catch (err) {\n        _didIteratorError18 = true;\n        _iteratorError18 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n            _iterator18.return();\n          }\n        } finally {\n          if (_didIteratorError18) {\n            throw _iteratorError18;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(opts) {\n      var path = this.path;\n\n      if (!path.isBlockStatement() && !path.isProgram()) {\n        path = this.getBlockParent().path;\n      }\n\n      if (path.isSwitchStatement()) {\n        path = (this.getFunctionParent() || this.getProgramParent()).path;\n      }\n\n      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n        path.ensureBlock();\n        path = path.get(\"body\");\n      }\n\n      var unique = opts.unique;\n      var kind = opts.kind || \"var\";\n      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n      var dataKey = \"declaration:\".concat(kind, \":\").concat(blockHoist);\n      var declarPath = !unique && path.getData(dataKey);\n\n      if (!declarPath) {\n        var declar = t.variableDeclaration(kind, []);\n        declar._blockHoist = blockHoist;\n\n        var _path$unshiftContaine = path.unshiftContainer(\"body\", [declar]);\n\n        var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);\n\n        declarPath = _path$unshiftContaine2[0];\n        if (!unique) path.setData(dataKey, declarPath);\n      }\n\n      var declarator = t.variableDeclarator(opts.id, opts.init);\n      declarPath.node.declarations.push(declarator);\n      this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n    }\n  }, {\n    key: \"getProgramParent\",\n    value: function getProgramParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isProgram()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      throw new Error(\"Couldn't find a Program\");\n    }\n  }, {\n    key: \"getFunctionParent\",\n    value: function getFunctionParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isFunctionParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      return null;\n    }\n  }, {\n    key: \"getBlockParent\",\n    value: function getBlockParent() {\n      var scope = this;\n\n      do {\n        if (scope.path.isBlockParent()) {\n          return scope;\n        }\n      } while (scope = scope.parent);\n\n      throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n    }\n  }, {\n    key: \"getAllBindings\",\n    value: function getAllBindings() {\n      var ids = Object.create(null);\n      var scope = this;\n\n      do {\n        (0, _defaults.default)(ids, scope.bindings);\n        scope = scope.parent;\n      } while (scope);\n\n      return ids;\n    }\n  }, {\n    key: \"getAllBindingsOfKind\",\n    value: function getAllBindingsOfKind() {\n      var ids = Object.create(null);\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = arguments[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var kind = _step19.value;\n          var scope = this;\n\n          do {\n            for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {\n              var name = _Object$keys6[_i6];\n              var binding = scope.bindings[name];\n              if (binding.kind === kind) ids[name] = binding;\n            }\n\n            scope = scope.parent;\n          } while (scope);\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n\n      return ids;\n    }\n  }, {\n    key: \"bindingIdentifierEquals\",\n    value: function bindingIdentifierEquals(name, node) {\n      return this.getBindingIdentifier(name) === node;\n    }\n  }, {\n    key: \"getBinding\",\n    value: function getBinding(name) {\n      var scope = this;\n\n      do {\n        var binding = scope.getOwnBinding(name);\n        if (binding) return binding;\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getOwnBinding\",\n    value: function getOwnBinding(name) {\n      return this.bindings[name];\n    }\n  }, {\n    key: \"getBindingIdentifier\",\n    value: function getBindingIdentifier(name) {\n      var info = this.getBinding(name);\n      return info && info.identifier;\n    }\n  }, {\n    key: \"getOwnBindingIdentifier\",\n    value: function getOwnBindingIdentifier(name) {\n      var binding = this.bindings[name];\n      return binding && binding.identifier;\n    }\n  }, {\n    key: \"hasOwnBinding\",\n    value: function hasOwnBinding(name) {\n      return !!this.getOwnBinding(name);\n    }\n  }, {\n    key: \"hasBinding\",\n    value: function hasBinding(name, noGlobals) {\n      if (!name) return false;\n      if (this.hasOwnBinding(name)) return true;\n      if (this.parentHasBinding(name, noGlobals)) return true;\n      if (this.hasUid(name)) return true;\n      if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;\n      if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;\n      return false;\n    }\n  }, {\n    key: \"parentHasBinding\",\n    value: function parentHasBinding(name, noGlobals) {\n      return this.parent && this.parent.hasBinding(name, noGlobals);\n    }\n  }, {\n    key: \"moveBindingTo\",\n    value: function moveBindingTo(name, scope) {\n      var info = this.getBinding(name);\n\n      if (info) {\n        info.scope.removeOwnBinding(name);\n        info.scope = scope;\n        scope.bindings[name] = info;\n      }\n    }\n  }, {\n    key: \"removeOwnBinding\",\n    value: function removeOwnBinding(name) {\n      delete this.bindings[name];\n    }\n  }, {\n    key: \"removeBinding\",\n    value: function removeBinding(name) {\n      var info = this.getBinding(name);\n\n      if (info) {\n        info.scope.removeOwnBinding(name);\n      }\n\n      var scope = this;\n\n      do {\n        if (scope.uids[name]) {\n          scope.uids[name] = false;\n        }\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      var parent = this.path.findParent(function (p) {\n        return p.isScope();\n      });\n      return parent && parent.scope;\n    }\n  }, {\n    key: \"parentBlock\",\n    get: function get() {\n      return this.path.parent;\n    }\n  }, {\n    key: \"hub\",\n    get: function get() {\n      return this.path.hub;\n    }\n  }]);\n\n  return Scope;\n}();\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/helpers/node_modules/@babel/traverse/lib/scope/index.js"],"names":["Object","defineProperty","exports","value","default","_includes","_interopRequireDefault","require","_repeat","_renamer","_index","_defaults","_binding","_globals","t","_interopRequireWildcard","_cache","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","gatherNodeParts","node","parts","isModuleDeclaration","source","specifiers","length","specifier","declaration","isModuleSpecifier","local","isMemberExpression","object","property","isIdentifier","push","name","isLiteral","isCallExpression","callee","isObjectExpression","isObjectPattern","properties","prop","argument","isPrivateName","id","isThisExpression","isSuper","collectorVisitor","For","path","FOR_INIT_KEYS","declar","isVar","parentScope","scope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","isDeclaration","parent","registerDeclaration","ReferencedIdentifier","state","references","ForXStatement","left","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","isVariableDeclaration","declarations","decl","keys","getBindingIdentifiers","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","ClassDeclaration","bindings","Block","paths","bodyPath","uid","Scope","cached","block","labels","Map","opts","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","uids","defaultName","isAssignmentExpression","isVariableDeclarator","isObjectProperty","isObjectMethod","join","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","duplicate","hub","buildError","TypeError","oldName","newName","rename","map","sep","console","log","type","violations","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","isLabeledStatement","registerLabel","isImportDeclaration","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","globals","constantsOnly","isClass","superClass","isPure","body","isClassBody","method","isBinary","right","elements","elem","isClassMethod","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","expression","isPureish","val","data","crawl","create","isLoop","isFunctionExpression","NOT_LOCAL_BINDING","isClassExpression","isFunction","params","param","isCatchClause","crawling","traverse","programParent","ref","isBlockStatement","isProgram","isSwitchStatement","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","init","pop","Error","isFunctionParent","isBlockParent","arguments","getBindingIdentifier","info","noGlobals","hasOwnBinding","parentHasBinding","hasUid","contextVariables","removeOwnBinding","findParent","p","isScope","builtin"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _defaults = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  if (t.isModuleDeclaration(node)) {\n    if (node.source) {\n      gatherNodeParts(node.source, parts);\n    } else if (node.specifiers && node.specifiers.length) {\n      for (const specifier of node.specifiers) {\n        gatherNodeParts(specifier, parts);\n      }\n    } else if (node.declaration) {\n      gatherNodeParts(node.declaration, parts);\n    }\n  } else if (t.isModuleSpecifier(node)) {\n    gatherNodeParts(node.local, parts);\n  } else if (t.isMemberExpression(node)) {\n    gatherNodeParts(node.object, parts);\n    gatherNodeParts(node.property, parts);\n  } else if (t.isIdentifier(node)) {\n    parts.push(node.name);\n  } else if (t.isLiteral(node)) {\n    parts.push(node.value);\n  } else if (t.isCallExpression(node)) {\n    gatherNodeParts(node.callee, parts);\n  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n    for (const prop of node.properties) {\n      gatherNodeParts(prop.key || prop.argument, parts);\n    }\n  } else if (t.isPrivateName(node)) {\n    gatherNodeParts(node.id, parts);\n  } else if (t.isThisExpression(node)) {\n    parts.push(\"this\");\n  } else if (t.isSuper(node)) {\n    parts.push(\"super\");\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    scope.getBlockParent().registerDeclaration(path);\n  },\n\n  ClassDeclaration(path) {\n    const id = path.node.id;\n    if (!id) return;\n    const name = id.name;\n    path.scope.bindings[name] = path.scope.getBinding(name);\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if (cached && cached.path === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent && parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 0;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(parent, defaultName) {\n    let node = parent;\n\n    if (t.isAssignmentExpression(parent)) {\n      node = parent.left;\n    } else if (t.isVariableDeclarator(parent)) {\n      node = parent.id;\n    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {\n      node = node.key;\n    }\n\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(parent, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(parent, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = (0, _repeat.default)(\"-\", 60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        parent.references[name] = true;\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    let scope = this;\n\n    do {\n      if (scope.references[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isClassMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.references) this.crawl();\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isLoop()) {\n      for (const key of t.FOR_INIT_KEYS) {\n        const node = path.get(key);\n        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n      }\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n    }\n\n    if (path.isClassExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path);\n      }\n    }\n\n    if (path.isFunction()) {\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    if (path.isCatchClause()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    const parent = this.getProgramParent();\n    if (parent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n      let programParent;\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent = programParent || path.scope.getProgramParent();\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        ref.scope.getProgramParent().addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      (0, _defaults.default)(ids, scope.bindings);\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) return binding;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    const info = this.getBinding(name);\n    return info && info.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding && binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    return this.parent && this.parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n    }\n\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"]},"metadata":{},"sourceType":"script"}