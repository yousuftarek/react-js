{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _path() {\n  var data = _interopRequireDefault(require(\"path\"));\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  var data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cloneDeep() {\n  var data = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\n  _cloneDeep = function _cloneDeep() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  var data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _parser() {\n  var data = require(\"@babel/parser\");\n\n  _parser = function _parser() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  var data = require(\"@babel/code-frame\");\n\n  _codeFrame = function _codeFrame() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = _interopRequireDefault(require(\"./file/file\"));\n\nvar _missingPluginHelper = _interopRequireDefault(require(\"./util/missing-plugin-helper\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = (0, _debug().default)(\"babel:transform:file\");\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  code = \"\".concat(code || \"\");\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = t().file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    ast = (0, _cloneDeep().default)(ast);\n  } else {\n    ast = parser(pluginPasses, options, code);\n  }\n\n  var inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      var lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      var _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && _lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromMapFileComment(\"//\".concat(_lastComment), _path().default.dirname(options.filename));\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (_lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code: code,\n    ast: ast,\n    inputMap: inputMap\n  });\n}\n\nfunction parser(pluginPasses, _ref, code) {\n  var parserOpts = _ref.parserOpts,\n      _ref$highlightCode = _ref.highlightCode,\n      highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode,\n      _ref$filename = _ref.filename,\n      filename = _ref$filename === void 0 ? \"unknown\" : _ref$filename;\n\n  try {\n    var results = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = pluginPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var plugins = _step.value;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = plugins[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var plugin = _step2.value;\n            var parserOverride = plugin.parserOverride;\n\n            if (parserOverride) {\n              var ast = parserOverride(code, parserOpts, _parser().parse);\n              if (ast !== undefined) results.push(ast);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      if (typeof results[0].then === \"function\") {\n        throw new Error(\"You appear to be using an async parser plugin, \" + \"which your current version of Babel does not support. \" + \"If you're using a published plugin, you may need to upgrade \" + \"your @babel/core version.\");\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    var loc = err.loc,\n        missingPlugin = err.missingPlugin;\n\n    if (loc) {\n      var codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode: highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = \"\".concat(filename, \": \") + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = \"\".concat(filename, \": \").concat(err.message, \"\\n\\n\") + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}\n\nvar INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nvar EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=(?:[^\\s'\"`]+?)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(function (_ref2) {\n      var value = _ref2.value;\n\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  var lastComment = null;\n  t().traverseFast(ast, function (node) {\n    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);\n\n    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);\n\n    node.leadingComments = _extractCommentsFromL2[0];\n    lastComment = _extractCommentsFromL2[1];\n\n    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);\n\n    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);\n\n    node.innerComments = _extractCommentsFromL4[0];\n    lastComment = _extractCommentsFromL4[1];\n\n    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);\n\n    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);\n\n    node.trailingComments = _extractCommentsFromL6[0];\n    lastComment = _extractCommentsFromL6[1];\n  });\n  return lastComment;\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/core/lib/transformation/normalize-file.js"],"names":["Object","defineProperty","exports","value","default","normalizeFile","_path","data","_interopRequireDefault","require","_debug","_cloneDeep","t","_interopRequireWildcard","_convertSourceMap","_parser","_codeFrame","_file","_missingPluginHelper","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","debug","pluginPasses","options","code","ast","type","file","Error","parser","inputMap","inputSourceMap","fromObject","lastComment","extractComments","INLINE_SOURCEMAP_REGEX","fromComment","err","EXTERNAL_SOURCEMAP_REGEX","filename","fromMapFileComment","dirname","parserOpts","highlightCode","results","plugins","plugin","parserOverride","parse","undefined","push","length","then","message","loc","missingPlugin","codeFrame","codeFrameColumns","start","line","column","extractCommentsFromList","regex","comments","filter","test","traverseFast","node","leadingComments","innerComments","trailingComments"],"mappings":"AAAA;;;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,aAAlB;;AAEA,SAASC,KAAT,GAAiB;AACf,MAAMC,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,MAAD,CAAR,CAAnC;;AAEAH,EAAAA,KAAK,GAAG,iBAAY;AAClB,WAAOC,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASG,MAAT,GAAkB;AAChB,MAAMH,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,OAAD,CAAR,CAAnC;;AAEAC,EAAAA,MAAM,GAAG,kBAAY;AACnB,WAAOH,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASI,UAAT,GAAsB;AACpB,MAAMJ,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAAnC;;AAEAE,EAAAA,UAAU,GAAG,sBAAY;AACvB,WAAOJ,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASK,CAAT,GAAa;AACX,MAAML,IAAI,GAAGM,uBAAuB,CAACJ,OAAO,CAAC,cAAD,CAAR,CAApC;;AAEAG,EAAAA,CAAC,GAAG,aAAY;AACd,WAAOL,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASO,iBAAT,GAA6B;AAC3B,MAAMP,IAAI,GAAGC,sBAAsB,CAACC,OAAO,CAAC,oBAAD,CAAR,CAAnC;;AAEAK,EAAAA,iBAAiB,GAAG,6BAAY;AAC9B,WAAOP,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASQ,OAAT,GAAmB;AACjB,MAAMR,IAAI,GAAGE,OAAO,CAAC,eAAD,CAApB;;AAEAM,EAAAA,OAAO,GAAG,mBAAY;AACpB,WAAOR,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASS,UAAT,GAAsB;AACpB,MAAMT,IAAI,GAAGE,OAAO,CAAC,mBAAD,CAApB;;AAEAO,EAAAA,UAAU,GAAG,sBAAY;AACvB,WAAOT,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,IAAIU,KAAK,GAAGT,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAlC;;AAEA,IAAIS,oBAAoB,GAAGV,sBAAsB,CAACC,OAAO,CAAC,8BAAD,CAAR,CAAjD;;AAEA,SAASU,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,oCAAY;AAAE,WAAOE,KAAP;AAAe,GAAxD;;AAA0D,SAAOA,KAAP;AAAe;;AAE1L,SAASR,uBAAT,CAAiCS,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AAAE,WAAOD,GAAP;AAAa;;AAAC,MAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;AAAE,WAAO;AAAElB,MAAAA,OAAO,EAAEkB;AAAX,KAAP;AAA0B;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACG,GAAN,CAAUF,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACI,GAAN,CAAUH,GAAV,CAAP;AAAwB;;AAAC,MAAII,MAAM,GAAG,EAAb;AAAiB,MAAIC,qBAAqB,GAAG3B,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAAC4B,wBAA5D;;AAAsF,OAAK,IAAIC,GAAT,IAAgBP,GAAhB,EAAqB;AAAE,QAAItB,MAAM,CAAC8B,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,GAArC,EAA0CO,GAA1C,CAAJ,EAAoD;AAAE,UAAII,IAAI,GAAGN,qBAAqB,GAAG3B,MAAM,CAAC4B,wBAAP,CAAgCN,GAAhC,EAAqCO,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,UAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAElC,QAAAA,MAAM,CAACC,cAAP,CAAsByB,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AAA2C,OAAjF,MAAuF;AAAEP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcP,GAAG,CAACO,GAAD,CAAjB;AAAyB;AAAE;AAAE;;AAACH,EAAAA,MAAM,CAACtB,OAAP,GAAiBkB,GAAjB;;AAAsB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACa,GAAN,CAAUZ,GAAV,EAAeI,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAEvuB,SAASlB,sBAAT,CAAgCc,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAElB,IAAAA,OAAO,EAAEkB;AAAX,GAArC;AAAwD;;AAE/F,IAAMa,KAAK,GAAG,CAAC,GAAGzB,MAAM,GAAGN,OAAb,EAAsB,sBAAtB,CAAd;;AAEA,SAASC,aAAT,CAAuB+B,YAAvB,EAAqCC,OAArC,EAA8CC,IAA9C,EAAoDC,GAApD,EAAyD;AACvDD,EAAAA,IAAI,aAAMA,IAAI,IAAI,EAAd,CAAJ;;AAEA,MAAIC,GAAJ,EAAS;AACP,QAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1BD,MAAAA,GAAG,GAAG3B,CAAC,GAAG6B,IAAJ,CAASF,GAAT,EAAc,EAAd,EAAkB,EAAlB,CAAN;AACD,KAFD,MAEO,IAAIA,GAAG,CAACC,IAAJ,KAAa,MAAjB,EAAyB;AAC9B,YAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAEDH,IAAAA,GAAG,GAAG,CAAC,GAAG5B,UAAU,GAAGP,OAAjB,EAA0BmC,GAA1B,CAAN;AACD,GARD,MAQO;AACLA,IAAAA,GAAG,GAAGI,MAAM,CAACP,YAAD,EAAeC,OAAf,EAAwBC,IAAxB,CAAZ;AACD;;AAED,MAAIM,QAAQ,GAAG,IAAf;;AAEA,MAAIP,OAAO,CAACQ,cAAR,KAA2B,KAA/B,EAAsC;AACpC,QAAI,OAAOR,OAAO,CAACQ,cAAf,KAAkC,QAAtC,EAAgD;AAC9CD,MAAAA,QAAQ,GAAG9B,iBAAiB,GAAGV,OAApB,CAA4B0C,UAA5B,CAAuCT,OAAO,CAACQ,cAA/C,CAAX;AACD;;AAED,QAAI,CAACD,QAAL,EAAe;AACb,UAAMG,WAAW,GAAGC,eAAe,CAACC,sBAAD,EAAyBV,GAAzB,CAAnC;;AAEA,UAAIQ,WAAJ,EAAiB;AACf,YAAI;AACFH,UAAAA,QAAQ,GAAG9B,iBAAiB,GAAGV,OAApB,CAA4B8C,WAA5B,CAAwCH,WAAxC,CAAX;AACD,SAFD,CAEE,OAAOI,GAAP,EAAY;AACZhB,UAAAA,KAAK,CAAC,2CAAD,EAA8CgB,GAA9C,CAAL;AACD;AACF;AACF;;AAED,QAAI,CAACP,QAAL,EAAe;AACb,UAAMG,YAAW,GAAGC,eAAe,CAACI,wBAAD,EAA2Bb,GAA3B,CAAnC;;AAEA,UAAI,OAAOF,OAAO,CAACgB,QAAf,KAA4B,QAA5B,IAAwCN,YAA5C,EAAyD;AACvD,YAAI;AACFH,UAAAA,QAAQ,GAAG9B,iBAAiB,GAAGV,OAApB,CAA4BkD,kBAA5B,aAAoDP,YAApD,GAAmEzC,KAAK,GAAGF,OAAR,CAAgBmD,OAAhB,CAAwBlB,OAAO,CAACgB,QAAhC,CAAnE,CAAX;AACD,SAFD,CAEE,OAAOF,GAAP,EAAY;AACZhB,UAAAA,KAAK,CAAC,yCAAD,EAA4CgB,GAA5C,CAAL;AACD;AACF,OAND,MAMO,IAAIJ,YAAJ,EAAiB;AACtBZ,QAAAA,KAAK,CAAC,6CAAD,CAAL;AACD;AACF;AACF;;AAED,SAAO,IAAIlB,KAAK,CAACb,OAAV,CAAkBiC,OAAlB,EAA2B;AAChCC,IAAAA,IAAI,EAAJA,IADgC;AAEhCC,IAAAA,GAAG,EAAHA,GAFgC;AAGhCK,IAAAA,QAAQ,EAARA;AAHgC,GAA3B,CAAP;AAKD;;AAED,SAASD,MAAT,CAAgBP,YAAhB,QAIGE,IAJH,EAIS;AAAA,MAHPkB,UAGO,QAHPA,UAGO;AAAA,gCAFPC,aAEO;AAAA,MAFPA,aAEO,mCAFS,IAET;AAAA,2BADPJ,QACO;AAAA,MADPA,QACO,8BADI,SACJ;;AACP,MAAI;AACF,QAAMK,OAAO,GAAG,EAAhB;AADE;AAAA;AAAA;;AAAA;AAGF,2BAAsBtB,YAAtB,8HAAoC;AAAA,YAAzBuB,OAAyB;AAAA;AAAA;AAAA;;AAAA;AAClC,gCAAqBA,OAArB,mIAA8B;AAAA,gBAAnBC,MAAmB;AAAA,gBAE1BC,cAF0B,GAGxBD,MAHwB,CAE1BC,cAF0B;;AAK5B,gBAAIA,cAAJ,EAAoB;AAClB,kBAAMtB,GAAG,GAAGsB,cAAc,CAACvB,IAAD,EAAOkB,UAAP,EAAmBzC,OAAO,GAAG+C,KAA7B,CAA1B;AACA,kBAAIvB,GAAG,KAAKwB,SAAZ,EAAuBL,OAAO,CAACM,IAAR,CAAazB,GAAb;AACxB;AACF;AAViC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWnC;AAdC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBF,QAAImB,OAAO,CAACO,MAAR,KAAmB,CAAvB,EAA0B;AACxB,aAAO,CAAC,GAAGlD,OAAO,GAAG+C,KAAd,EAAqBxB,IAArB,EAA2BkB,UAA3B,CAAP;AACD,KAFD,MAEO,IAAIE,OAAO,CAACO,MAAR,KAAmB,CAAvB,EAA0B;AAC/B,UAAI,OAAOP,OAAO,CAAC,CAAD,CAAP,CAAWQ,IAAlB,KAA2B,UAA/B,EAA2C;AACzC,cAAM,IAAIxB,KAAJ,CAAU,2MAAV,CAAN;AACD;;AAED,aAAOgB,OAAO,CAAC,CAAD,CAAd;AACD;;AAED,UAAM,IAAIhB,KAAJ,CAAU,qDAAV,CAAN;AACD,GA3BD,CA2BE,OAAOS,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACb,IAAJ,KAAa,yCAAjB,EAA4D;AAC1Da,MAAAA,GAAG,CAACgB,OAAJ,IAAe,0EAA0E,+DAAzF;AACD;;AAHW,QAMVC,GANU,GAQRjB,GARQ,CAMViB,GANU;AAAA,QAOVC,aAPU,GAQRlB,GARQ,CAOVkB,aAPU;;AAUZ,QAAID,GAAJ,EAAS;AACP,UAAME,SAAS,GAAG,CAAC,GAAGtD,UAAU,GAAGuD,gBAAjB,EAAmCjC,IAAnC,EAAyC;AACzDkC,QAAAA,KAAK,EAAE;AACLC,UAAAA,IAAI,EAAEL,GAAG,CAACK,IADL;AAELC,UAAAA,MAAM,EAAEN,GAAG,CAACM,MAAJ,GAAa;AAFhB;AADkD,OAAzC,EAKf;AACDjB,QAAAA,aAAa,EAAbA;AADC,OALe,CAAlB;;AASA,UAAIY,aAAJ,EAAmB;AACjBlB,QAAAA,GAAG,CAACgB,OAAJ,GAAc,UAAGd,QAAH,UAAkB,CAAC,GAAGnC,oBAAoB,CAACd,OAAzB,EAAkCiE,aAAa,CAAC,CAAD,CAA/C,EAAoDD,GAApD,EAAyDE,SAAzD,CAAhC;AACD,OAFD,MAEO;AACLnB,QAAAA,GAAG,CAACgB,OAAJ,GAAc,UAAGd,QAAH,eAAgBF,GAAG,CAACgB,OAApB,YAAoCG,SAAlD;AACD;;AAEDnB,MAAAA,GAAG,CAACb,IAAJ,GAAW,mBAAX;AACD;;AAED,UAAMa,GAAN;AACD;AACF;;AAED,IAAMF,sBAAsB,GAAG,8FAA/B;AACA,IAAMG,wBAAwB,GAAG,mDAAjC;;AAEA,SAASuB,uBAAT,CAAiCC,KAAjC,EAAwCC,QAAxC,EAAkD9B,WAAlD,EAA+D;AAC7D,MAAI8B,QAAJ,EAAc;AACZA,IAAAA,QAAQ,GAAGA,QAAQ,CAACC,MAAT,CAAgB,iBAErB;AAAA,UADJ3E,KACI,SADJA,KACI;;AACJ,UAAIyE,KAAK,CAACG,IAAN,CAAW5E,KAAX,CAAJ,EAAuB;AACrB4C,QAAAA,WAAW,GAAG5C,KAAd;AACA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,KATU,CAAX;AAUD;;AAED,SAAO,CAAC0E,QAAD,EAAW9B,WAAX,CAAP;AACD;;AAED,SAASC,eAAT,CAAyB4B,KAAzB,EAAgCrC,GAAhC,EAAqC;AACnC,MAAIQ,WAAW,GAAG,IAAlB;AACAnC,EAAAA,CAAC,GAAGoE,YAAJ,CAAiBzC,GAAjB,EAAsB,UAAA0C,IAAI,EAAI;AAAA,gCACUN,uBAAuB,CAACC,KAAD,EAAQK,IAAI,CAACC,eAAb,EAA8BnC,WAA9B,CADjC;;AAAA;;AAC3BkC,IAAAA,IAAI,CAACC,eADsB;AACLnC,IAAAA,WADK;;AAAA,iCAEQ4B,uBAAuB,CAACC,KAAD,EAAQK,IAAI,CAACE,aAAb,EAA4BpC,WAA5B,CAF/B;;AAAA;;AAE3BkC,IAAAA,IAAI,CAACE,aAFsB;AAEPpC,IAAAA,WAFO;;AAAA,iCAGW4B,uBAAuB,CAACC,KAAD,EAAQK,IAAI,CAACG,gBAAb,EAA+BrC,WAA/B,CAHlC;;AAAA;;AAG3BkC,IAAAA,IAAI,CAACG,gBAHsB;AAGJrC,IAAAA,WAHI;AAI7B,GAJD;AAKA,SAAOA,WAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cloneDeep() {\n  const data = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\n  _cloneDeep = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n\n  _parser = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n\n  _codeFrame = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = _interopRequireDefault(require(\"./file/file\"));\n\nvar _missingPluginHelper = _interopRequireDefault(require(\"./util/missing-plugin-helper\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:transform:file\");\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = t().file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    ast = (0, _cloneDeep().default)(ast);\n  } else {\n    ast = parser(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          inputMap = _convertSourceMap().default.fromMapFileComment(`//${lastComment}`, _path().default.dirname(options.filename));\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code,\n    ast,\n    inputMap\n  });\n}\n\nfunction parser(pluginPasses, {\n  parserOpts,\n  highlightCode = true,\n  filename = \"unknown\"\n}, code) {\n  try {\n    const results = [];\n\n    for (const plugins of pluginPasses) {\n      for (const plugin of plugins) {\n        const {\n          parserOverride\n        } = plugin;\n\n        if (parserOverride) {\n          const ast = parserOverride(code, parserOpts, _parser().parse);\n          if (ast !== undefined) results.push(ast);\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      if (typeof results[0].then === \"function\") {\n        throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    const {\n      loc,\n      missingPlugin\n    } = err;\n\n    if (loc) {\n      const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = `${filename}: ${err.message}\\n\\n` + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}\n\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=(?:[^\\s'\"`]+?)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(({\n      value\n    }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  t().traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}"]},"metadata":{},"sourceType":"script"}