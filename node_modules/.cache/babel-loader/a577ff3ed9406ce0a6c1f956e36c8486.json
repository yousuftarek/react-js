{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/hyper/yousuftarek/bookstore/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeStrongCache = makeStrongCache;\nexports.makeWeakCache = makeWeakCache;\nexports.assertSimpleType = assertSimpleType;\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(new Map(), handler);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(new WeakMap(), handler);\n}\n\nfunction makeCachedFunction(callCache, handler) {\n  return function cachedFunction(arg, data) {\n    var cachedValue = callCache.get(arg);\n\n    if (cachedValue) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = cachedValue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref2 = _step.value;\n          var _value = _ref2.value;\n          var valid = _ref2.valid;\n          if (valid(data)) return _value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    var cache = new CacheConfigurator(data);\n    var value = handler(arg, cache);\n    if (!cache.configured()) cache.forever();\n    cache.deactivate();\n\n    switch (cache.mode()) {\n      case \"forever\":\n        cachedValue = [{\n          value: value,\n          valid: function valid() {\n            return true;\n          }\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"invalidate\":\n        cachedValue = [{\n          value: value,\n          valid: cache.validator()\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"valid\":\n        if (cachedValue) {\n          cachedValue.push({\n            value: value,\n            valid: cache.validator()\n          });\n        } else {\n          cachedValue = [{\n            value: value,\n            valid: cache.validator()\n          }];\n          callCache.set(arg, cachedValue);\n        }\n\n    }\n\n    return value;\n  };\n}\n\nvar CacheConfigurator =\n/*#__PURE__*/\nfunction () {\n  function CacheConfigurator(data) {\n    _classCallCheck(this, CacheConfigurator);\n\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = data;\n  }\n\n  _createClass(CacheConfigurator, [{\n    key: \"simple\",\n    value: function simple() {\n      return makeSimpleConfigurator(this);\n    }\n  }, {\n    key: \"mode\",\n    value: function mode() {\n      if (this._never) return \"never\";\n      if (this._forever) return \"forever\";\n      if (this._invalidate) return \"invalidate\";\n      return \"valid\";\n    }\n  }, {\n    key: \"forever\",\n    value: function forever() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never) {\n        throw new Error(\"Caching has already been configured with .never()\");\n      }\n\n      this._forever = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"never\",\n    value: function never() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._forever) {\n        throw new Error(\"Caching has already been configured with .forever()\");\n      }\n\n      this._never = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"using\",\n    value: function using(handler) {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never || this._forever) {\n        throw new Error(\"Caching has already been configured with .never or .forever()\");\n      }\n\n      this._configured = true;\n      var key = handler(this._data);\n\n      this._pairs.push([key, handler]);\n\n      return key;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(handler) {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never || this._forever) {\n        throw new Error(\"Caching has already been configured with .never or .forever()\");\n      }\n\n      this._invalidate = true;\n      this._configured = true;\n      var key = handler(this._data);\n\n      this._pairs.push([key, handler]);\n\n      return key;\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var pairs = this._pairs;\n      return function (data) {\n        return pairs.every(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              key = _ref4[0],\n              fn = _ref4[1];\n\n          return key === fn(data);\n        });\n      };\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      this._active = false;\n    }\n  }, {\n    key: \"configured\",\n    value: function configured() {\n      return this._configured;\n    }\n  }]);\n\n  return CacheConfigurator;\n}();\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(function () {\n      return assertSimpleType(val());\n    });\n  }\n\n  cacheFn.forever = function () {\n    return cache.forever();\n  };\n\n  cacheFn.never = function () {\n    return cache.never();\n  };\n\n  cacheFn.using = function (cb) {\n    return cache.using(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  cacheFn.invalidate = function (cb) {\n    return cache.invalidate(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/core/lib/config/caching.js"],"names":["Object","defineProperty","exports","value","makeStrongCache","makeWeakCache","assertSimpleType","handler","makeCachedFunction","Map","WeakMap","callCache","cachedFunction","arg","data","cachedValue","get","valid","cache","CacheConfigurator","configured","forever","deactivate","mode","set","validator","push","_active","_never","_forever","_invalidate","_configured","_pairs","_data","makeSimpleConfigurator","Error","key","pairs","every","fn","cacheFn","val","never","using","cb","invalidate"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeStrongCache = makeStrongCache;\nexports.makeWeakCache = makeWeakCache;\nexports.assertSimpleType = assertSimpleType;\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(new Map(), handler);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(new WeakMap(), handler);\n}\n\nfunction makeCachedFunction(callCache, handler) {\n  return function cachedFunction(arg, data) {\n    let cachedValue = callCache.get(arg);\n\n    if (cachedValue) {\n      for (const {\n        value,\n        valid\n      } of cachedValue) {\n        if (valid(data)) return value;\n      }\n    }\n\n    const cache = new CacheConfigurator(data);\n    const value = handler(arg, cache);\n    if (!cache.configured()) cache.forever();\n    cache.deactivate();\n\n    switch (cache.mode()) {\n      case \"forever\":\n        cachedValue = [{\n          value,\n          valid: () => true\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"invalidate\":\n        cachedValue = [{\n          value,\n          valid: cache.validator()\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"valid\":\n        if (cachedValue) {\n          cachedValue.push({\n            value,\n            valid: cache.validator()\n          });\n        } else {\n          cachedValue = [{\n            value,\n            valid: cache.validator()\n          }];\n          callCache.set(arg, cachedValue);\n        }\n\n    }\n\n    return value;\n  };\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n\n    this._pairs.push([key, handler]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._invalidate = true;\n    this._configured = true;\n    const key = handler(this._data);\n\n    this._pairs.push([key, handler]);\n\n    return key;\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return data => pairs.every(([key, fn]) => key === fn(data));\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"script"}