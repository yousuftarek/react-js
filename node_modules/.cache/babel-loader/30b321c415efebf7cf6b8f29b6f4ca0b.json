{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\n\nfunction _sourceMap() {\n  var data = _interopRequireDefault(require(\"source-map\"));\n\n  _sourceMap = function _sourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction mergeSourceMap(inputMap, map) {\n  var input = buildMappingData(inputMap);\n  var output = buildMappingData(map);\n  var mergedGenerator = new (_sourceMap().default.SourceMapGenerator)();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = input.sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref2 = _step.value;\n      var source = _ref2.source;\n\n      if (typeof source.content === \"string\") {\n        mergedGenerator.setSourceContent(source.path, source.content);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (output.sources.length === 1) {\n    var defaultSource = output.sources[0];\n    var insertedMappings = new Map();\n    eachInputGeneratedRange(input, function (generated, original, source) {\n      eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {\n        var key = makeMappingKey(item);\n        if (insertedMappings.has(key)) return;\n        insertedMappings.set(key, item);\n        mergedGenerator.addMapping({\n          source: source.path,\n          original: {\n            line: original.line,\n            column: original.columnStart\n          },\n          generated: {\n            line: item.line,\n            column: item.columnStart\n          },\n          name: original.name\n        });\n      });\n    });\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = insertedMappings.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var item = _step2.value;\n\n        if (item.columnEnd === Infinity) {\n          continue;\n        }\n\n        var clearItem = {\n          line: item.line,\n          columnStart: item.columnEnd\n        };\n        var key = makeMappingKey(clearItem);\n\n        if (insertedMappings.has(key)) {\n          continue;\n        }\n\n        mergedGenerator.addMapping({\n          generated: {\n            line: clearItem.line,\n            column: clearItem.columnStart\n          }\n        });\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  var result = mergedGenerator.toJSON();\n\n  if (typeof input.sourceRoot === \"string\") {\n    result.sourceRoot = input.sourceRoot;\n  }\n\n  return result;\n}\n\nfunction makeMappingKey(item) {\n  return \"\".concat(item.line, \"/\").concat(item.columnStart);\n}\n\nfunction eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {\n  var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = overlappingOriginal[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _ref4 = _step3.value;\n      var generated = _ref4.generated;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = generated[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var item = _step4.value;\n          callback(item);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction filterApplicableOriginalRanges(_ref5, _ref6) {\n  var mappings = _ref5.mappings;\n  var line = _ref6.line,\n      columnStart = _ref6.columnStart,\n      columnEnd = _ref6.columnEnd;\n  return filterSortedArray(mappings, function (_ref7) {\n    var outOriginal = _ref7.original;\n    if (line > outOriginal.line) return -1;\n    if (line < outOriginal.line) return 1;\n    if (columnStart >= outOriginal.columnEnd) return -1;\n    if (columnEnd <= outOriginal.columnStart) return 1;\n    return 0;\n  });\n}\n\nfunction eachInputGeneratedRange(map, callback) {\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = map.sources[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var _ref9 = _step5.value;\n      var source = _ref9.source;\n      var mappings = _ref9.mappings;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = mappings[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _ref11 = _step6.value;\n          var original = _ref11.original;\n          var generated = _ref11.generated;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = generated[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var item = _step7.value;\n              callback(item, original, source);\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction buildMappingData(map) {\n  var consumer = new (_sourceMap().default.SourceMapConsumer)(Object.assign({}, map, {\n    sourceRoot: null\n  }));\n  var sources = new Map();\n  var mappings = new Map();\n  var last = null;\n  consumer.computeColumnSpans();\n  consumer.eachMapping(function (m) {\n    if (m.originalLine === null) return;\n    var source = sources.get(m.source);\n\n    if (!source) {\n      source = {\n        path: m.source,\n        content: consumer.sourceContentFor(m.source, true)\n      };\n      sources.set(m.source, source);\n    }\n\n    var sourceData = mappings.get(source);\n\n    if (!sourceData) {\n      sourceData = {\n        source: source,\n        mappings: []\n      };\n      mappings.set(source, sourceData);\n    }\n\n    var obj = {\n      line: m.originalLine,\n      columnStart: m.originalColumn,\n      columnEnd: Infinity,\n      name: m.name\n    };\n\n    if (last && last.source === source && last.mapping.line === m.originalLine) {\n      last.mapping.columnEnd = m.originalColumn;\n    }\n\n    last = {\n      source: source,\n      mapping: obj\n    };\n    sourceData.mappings.push({\n      original: obj,\n      generated: consumer.allGeneratedPositionsFor({\n        source: m.source,\n        line: m.originalLine,\n        column: m.originalColumn\n      }).map(function (item) {\n        return {\n          line: item.line,\n          columnStart: item.column,\n          columnEnd: item.lastColumn + 1\n        };\n      })\n    });\n  }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);\n  return {\n    file: map.file,\n    sourceRoot: map.sourceRoot,\n    sources: Array.from(mappings.values())\n  };\n}\n\nfunction findInsertionLocation(array, callback) {\n  var left = 0;\n  var right = array.length;\n\n  while (left < right) {\n    var mid = Math.floor((left + right) / 2);\n    var item = array[mid];\n    var result = callback(item);\n\n    if (result === 0) {\n      left = mid;\n      break;\n    }\n\n    if (result >= 0) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  var i = left;\n\n  if (i < array.length) {\n    while (i >= 0 && callback(array[i]) >= 0) {\n      i--;\n    }\n\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction filterSortedArray(array, callback) {\n  var start = findInsertionLocation(array, callback);\n  var results = [];\n\n  for (var i = start; i < array.length && callback(array[i]) === 0; i++) {\n    results.push(array[i]);\n  }\n\n  return results;\n}","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/core/lib/transformation/file/merge-map.js"],"names":["Object","defineProperty","exports","value","default","mergeSourceMap","_sourceMap","data","_interopRequireDefault","require","obj","__esModule","inputMap","map","input","buildMappingData","output","mergedGenerator","SourceMapGenerator","sources","source","content","setSourceContent","path","length","defaultSource","insertedMappings","Map","eachInputGeneratedRange","generated","original","eachOverlappingGeneratedOutputRange","item","key","makeMappingKey","has","set","addMapping","line","column","columnStart","name","values","columnEnd","Infinity","clearItem","result","toJSON","sourceRoot","outputFile","inputGeneratedRange","callback","overlappingOriginal","filterApplicableOriginalRanges","mappings","filterSortedArray","outOriginal","consumer","SourceMapConsumer","assign","last","computeColumnSpans","eachMapping","m","originalLine","get","sourceContentFor","sourceData","originalColumn","mapping","push","allGeneratedPositionsFor","lastColumn","ORIGINAL_ORDER","file","Array","from","findInsertionLocation","array","left","right","mid","Math","floor","i","start","results"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\n\nfunction _sourceMap() {\n  const data = _interopRequireDefault(require(\"source-map\"));\n\n  _sourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction mergeSourceMap(inputMap, map) {\n  const input = buildMappingData(inputMap);\n  const output = buildMappingData(map);\n  const mergedGenerator = new (_sourceMap().default.SourceMapGenerator)();\n\n  for (const {\n    source\n  } of input.sources) {\n    if (typeof source.content === \"string\") {\n      mergedGenerator.setSourceContent(source.path, source.content);\n    }\n  }\n\n  if (output.sources.length === 1) {\n    const defaultSource = output.sources[0];\n    const insertedMappings = new Map();\n    eachInputGeneratedRange(input, (generated, original, source) => {\n      eachOverlappingGeneratedOutputRange(defaultSource, generated, item => {\n        const key = makeMappingKey(item);\n        if (insertedMappings.has(key)) return;\n        insertedMappings.set(key, item);\n        mergedGenerator.addMapping({\n          source: source.path,\n          original: {\n            line: original.line,\n            column: original.columnStart\n          },\n          generated: {\n            line: item.line,\n            column: item.columnStart\n          },\n          name: original.name\n        });\n      });\n    });\n\n    for (const item of insertedMappings.values()) {\n      if (item.columnEnd === Infinity) {\n        continue;\n      }\n\n      const clearItem = {\n        line: item.line,\n        columnStart: item.columnEnd\n      };\n      const key = makeMappingKey(clearItem);\n\n      if (insertedMappings.has(key)) {\n        continue;\n      }\n\n      mergedGenerator.addMapping({\n        generated: {\n          line: clearItem.line,\n          column: clearItem.columnStart\n        }\n      });\n    }\n  }\n\n  const result = mergedGenerator.toJSON();\n\n  if (typeof input.sourceRoot === \"string\") {\n    result.sourceRoot = input.sourceRoot;\n  }\n\n  return result;\n}\n\nfunction makeMappingKey(item) {\n  return `${item.line}/${item.columnStart}`;\n}\n\nfunction eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {\n  const overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);\n\n  for (const {\n    generated\n  } of overlappingOriginal) {\n    for (const item of generated) {\n      callback(item);\n    }\n  }\n}\n\nfunction filterApplicableOriginalRanges({\n  mappings\n}, {\n  line,\n  columnStart,\n  columnEnd\n}) {\n  return filterSortedArray(mappings, ({\n    original: outOriginal\n  }) => {\n    if (line > outOriginal.line) return -1;\n    if (line < outOriginal.line) return 1;\n    if (columnStart >= outOriginal.columnEnd) return -1;\n    if (columnEnd <= outOriginal.columnStart) return 1;\n    return 0;\n  });\n}\n\nfunction eachInputGeneratedRange(map, callback) {\n  for (const {\n    source,\n    mappings\n  } of map.sources) {\n    for (const {\n      original,\n      generated\n    } of mappings) {\n      for (const item of generated) {\n        callback(item, original, source);\n      }\n    }\n  }\n}\n\nfunction buildMappingData(map) {\n  const consumer = new (_sourceMap().default.SourceMapConsumer)(Object.assign({}, map, {\n    sourceRoot: null\n  }));\n  const sources = new Map();\n  const mappings = new Map();\n  let last = null;\n  consumer.computeColumnSpans();\n  consumer.eachMapping(m => {\n    if (m.originalLine === null) return;\n    let source = sources.get(m.source);\n\n    if (!source) {\n      source = {\n        path: m.source,\n        content: consumer.sourceContentFor(m.source, true)\n      };\n      sources.set(m.source, source);\n    }\n\n    let sourceData = mappings.get(source);\n\n    if (!sourceData) {\n      sourceData = {\n        source,\n        mappings: []\n      };\n      mappings.set(source, sourceData);\n    }\n\n    const obj = {\n      line: m.originalLine,\n      columnStart: m.originalColumn,\n      columnEnd: Infinity,\n      name: m.name\n    };\n\n    if (last && last.source === source && last.mapping.line === m.originalLine) {\n      last.mapping.columnEnd = m.originalColumn;\n    }\n\n    last = {\n      source,\n      mapping: obj\n    };\n    sourceData.mappings.push({\n      original: obj,\n      generated: consumer.allGeneratedPositionsFor({\n        source: m.source,\n        line: m.originalLine,\n        column: m.originalColumn\n      }).map(item => ({\n        line: item.line,\n        columnStart: item.column,\n        columnEnd: item.lastColumn + 1\n      }))\n    });\n  }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);\n  return {\n    file: map.file,\n    sourceRoot: map.sourceRoot,\n    sources: Array.from(mappings.values())\n  };\n}\n\nfunction findInsertionLocation(array, callback) {\n  let left = 0;\n  let right = array.length;\n\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const item = array[mid];\n    const result = callback(item);\n\n    if (result === 0) {\n      left = mid;\n      break;\n    }\n\n    if (result >= 0) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  let i = left;\n\n  if (i < array.length) {\n    while (i >= 0 && callback(array[i]) >= 0) {\n      i--;\n    }\n\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction filterSortedArray(array, callback) {\n  const start = findInsertionLocation(array, callback);\n  const results = [];\n\n  for (let i = start; i < array.length && callback(array[i]) === 0; i++) {\n    results.push(array[i]);\n  }\n\n  return results;\n}"]},"metadata":{},"sourceType":"script"}