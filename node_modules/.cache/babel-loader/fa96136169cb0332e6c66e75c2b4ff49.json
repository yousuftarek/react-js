{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;\n\nfunction makeStatementFormatter(fn) {\n  return {\n    code: function code(str) {\n      return \"/* @babel/template */;\\n\".concat(str);\n    },\n    validate: function validate() {},\n    unwrap: function unwrap(ast) {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\n\nvar smart = makeStatementFormatter(function (body) {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nexports.smart = smart;\nvar statements = makeStatementFormatter(function (body) {\n  return body;\n});\nexports.statements = statements;\nvar statement = makeStatementFormatter(function (body) {\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\nexports.statement = statement;\nvar expression = {\n  code: function code(str) {\n    return \"(\\n\".concat(str, \"\\n)\");\n  },\n  validate: function validate(_ref) {\n    var program = _ref.program;\n\n    if (program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n\n    var expression = program.body[0].expression;\n\n    if (expression.start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: function unwrap(ast) {\n    return ast.program.body[0].expression;\n  }\n};\nexports.expression = expression;\nvar program = {\n  code: function code(str) {\n    return str;\n  },\n  validate: function validate() {},\n  unwrap: function unwrap(ast) {\n    return ast.program;\n  }\n};\nexports.program = program;","map":{"version":3,"sources":["/home/hyper/yousuftarek/bookstore/node_modules/@babel/helpers/node_modules/@babel/template/lib/formatters.js"],"names":["Object","defineProperty","exports","value","program","expression","statement","statements","smart","makeStatementFormatter","fn","code","str","validate","unwrap","ast","body","slice","length","Error","start"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBF,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,SAAR,GAAoBJ,OAAO,CAACK,UAAR,GAAqBL,OAAO,CAACM,KAAR,GAAgB,KAAK,CAArG;;AAEA,SAASC,sBAAT,CAAgCC,EAAhC,EAAoC;AAClC,SAAO;AACLC,IAAAA,IAAI,EAAE,cAAAC,GAAG;AAAA,+CAA+BA,GAA/B;AAAA,KADJ;AAELC,IAAAA,QAAQ,EAAE,oBAAM,CAAE,CAFb;AAGLC,IAAAA,MAAM,EAAE,gBAAAC,GAAG,EAAI;AACb,aAAOL,EAAE,CAACK,GAAG,CAACX,OAAJ,CAAYY,IAAZ,CAAiBC,KAAjB,CAAuB,CAAvB,CAAD,CAAT;AACD;AALI,GAAP;AAOD;;AAED,IAAMT,KAAK,GAAGC,sBAAsB,CAAC,UAAAO,IAAI,EAAI;AAC3C,MAAIA,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACnB,WAAOF,IAAP;AACD,GAFD,MAEO;AACL,WAAOA,IAAI,CAAC,CAAD,CAAX;AACD;AACF,CANmC,CAApC;AAOAd,OAAO,CAACM,KAAR,GAAgBA,KAAhB;AACA,IAAMD,UAAU,GAAGE,sBAAsB,CAAC,UAAAO,IAAI;AAAA,SAAIA,IAAJ;AAAA,CAAL,CAAzC;AACAd,OAAO,CAACK,UAAR,GAAqBA,UAArB;AACA,IAAMD,SAAS,GAAGG,sBAAsB,CAAC,UAAAO,IAAI,EAAI;AAC/C,MAAIA,IAAI,CAACE,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACD;;AAED,MAAIH,IAAI,CAACE,MAAL,GAAc,CAAlB,EAAqB;AACnB,UAAM,IAAIC,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,SAAOH,IAAI,CAAC,CAAD,CAAX;AACD,CAVuC,CAAxC;AAWAd,OAAO,CAACI,SAAR,GAAoBA,SAApB;AACA,IAAMD,UAAU,GAAG;AACjBM,EAAAA,IAAI,EAAE,cAAAC,GAAG;AAAA,wBAAUA,GAAV;AAAA,GADQ;AAEjBC,EAAAA,QAAQ,EAAE,wBAEJ;AAAA,QADJT,OACI,QADJA,OACI;;AACJ,QAAIA,OAAO,CAACY,IAAR,CAAaE,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAIC,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,QAAMd,UAAU,GAAGD,OAAO,CAACY,IAAR,CAAa,CAAb,EAAgBX,UAAnC;;AAEA,QAAIA,UAAU,CAACe,KAAX,KAAqB,CAAzB,EAA4B;AAC1B,YAAM,IAAID,KAAJ,CAAU,+BAAV,CAAN;AACD;AACF,GAdgB;AAejBL,EAAAA,MAAM,EAAE,gBAAAC,GAAG;AAAA,WAAIA,GAAG,CAACX,OAAJ,CAAYY,IAAZ,CAAiB,CAAjB,EAAoBX,UAAxB;AAAA;AAfM,CAAnB;AAiBAH,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACA,IAAMD,OAAO,GAAG;AACdO,EAAAA,IAAI,EAAE,cAAAC,GAAG;AAAA,WAAIA,GAAJ;AAAA,GADK;AAEdC,EAAAA,QAAQ,EAAE,oBAAM,CAAE,CAFJ;AAGdC,EAAAA,MAAM,EAAE,gBAAAC,GAAG;AAAA,WAAIA,GAAG,CAACX,OAAR;AAAA;AAHG,CAAhB;AAKAF,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;\n\nfunction makeStatementFormatter(fn) {\n  return {\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: ast => {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\n\nconst smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nexports.smart = smart;\nconst statements = makeStatementFormatter(body => body);\nexports.statements = statements;\nconst statement = makeStatementFormatter(body => {\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\nexports.statement = statement;\nconst expression = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ({\n    program\n  }) => {\n    if (program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n\n    const expression = program.body[0].expression;\n\n    if (expression.start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ast => ast.program.body[0].expression\n};\nexports.expression = expression;\nconst program = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program\n};\nexports.program = program;"]},"metadata":{},"sourceType":"script"}